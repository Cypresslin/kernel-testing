#!/usr/bin/env python
#

import sys
import os
import copy
from time                               import sleep
from datetime                           import datetime
from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, warning, DEBUG, INFO
from lib.msgq                           import MsgQueue
from lib.testsprops                     import SRU_TestsList, LKP_TestsList, BOOT_TestsList, LivepatchSnappyClientPayloadTests
from lib.log                            import cdebug, center, cleave
from lib.utils                          import date_to_string
import json

from mako.template                      import Template
from mako.exceptions                    import RichTraceback
from lib.jenkins                        import Jenkins


# Exit
#
class Exit():
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass


# TheApp
#
class TheApp():
    '''
    This class is just the engine that makes everything go.
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.args = args
        s.jenkins_url_default = "http://localhost:8080"
        s.jenkins = Jenkins(s.jenkins_url_default)
        s.job_defaults = {
            'key'            : 'kernel.testing.request',
            'who'            : None,
            'op'             : 'bogus',
            'date'           : '1960.11.02_08.00.00',
            'hwe'            : False,
            'ppa'            : None,
            'url'            : None,
            'decoration'     : None,
            'fs-benchmarks'  : None,
            'kernel'         : None,
            'lkp'            : False
        }

        if s.args.lkp:
            s.job_defaults['key'] = 'kernel.testing.livekernelpatching.request'
            s.job_defaults['lkp'] = True

        s.jjc = os.path.dirname(sys.argv[0])
        s.jjc = os.path.join(s.jjc, 'jenkins-job-creator', 'jjc')

        # A list of the packages that we don't test.
        #
        s.package_blacklist = [
            'linux-keystone',
            'linux-armadaxp',
            'linux-ec2',
            'linux-exynos5',
            'linux-ti-omap4',
            'linux-raspi2',
            'linux-snapdragon',
        ]

    # dyno
    #
    def dyno(s):
        '''
        There are some things that need to be more dynamic. Changes to
        lib/configuration.py or the standard-jenkins-test-job.mako files
        shouldn't require killing the running kmsgq-jenkins job.
        '''
        center('TheApp::dyno')

        import lib.configuration
        s.configuration = lib.configuration.Configuration

        # Create a dictionary of the lab HW keyed by role.
        #
        s.sut_pool = {}
        for sut in s.configuration['systems']:
            try:
                for role in s.configuration['systems'][sut]['role']:
                    try:
                        s.sut_pool[role].append(sut)
                    except:
                        s.sut_pool[role] = []
                        s.sut_pool[role].append(sut)
            except TypeError:
                print('s.configuration[\'systems\'][sut][\'role\'] missing for %s' % sut)
                raise

        if s.args.debug:
            cdebug(json.dumps(s.sut_pool, sort_keys=True, indent=4))

        s.job_template = s.load_template('standard-jenkins-test-job.mako')

        cleave('TheApp::dyno')

    # job_name
    #
    def job_name(s, jd, arch, system, tests):
        center('TheApp::job_name')
        retval = ""

        # The job name starts with some form of the test name(s)
        #
        cdebug('tests: %s (%s)' % (tests, type(tests)))
        if isinstance(tests, str) or isinstance(tests, unicode):
            retval += tests
            retval += '__'
        else:
            retval += '-'.join(tests)
            retval = retval.replace('ubuntu', 'u')
            retval += '__'

        if s.args.lkp:
            retval += jd['package']
        else:
            retval += jd['series-name'].title()[0]  # Only want the first character
        if jd['hwe']:
            retval += '-hwe'

        if 'series-decoration' in jd and jd['series-decoration'] is not None:
            retval += '_%s' % jd['series-decoration']

        retval += '_%s__using_%s' % (arch, system)

        if jd['who'] is not None:
            retval += '__for_%s' % '_'.join(jd['who'])

        cdebug('job name: %s' % (retval))
        cleave('TheApp::job_name')
        return retval

    # handle_request
    #
    def handle_request(s, jd):
        center('TheApp::handle_request')
        s._dump(jd)

        s.from_tests_generate_jobs(jd)

        cleave('TheApp::handle_request')

    # handle_kernel_publish
    #
    def handle_kernel_publish(s, jd):
        center('TheApp::handle_kernel_publish')
        s._dump(jd)

        jd['series-decoration'] = 'SRU'
        jd['who'] = None

        s.from_tests_generate_jobs(jd)

        cleave('TheApp::handle_kernel_publish')

    # from_tests_generate_jobs
    #
    def from_tests_generate_jobs(s, jd):
        center('TheApp::from_tests_generate_jobs')

        jd['jobs'] = []

        for test in jd['tests']:
            cdebug('test: %s' % test, 'blue')

            # Note: jd['systems'] should never be empty when we get here. If it is then _handler isn't doing
            #       it's job.

            try:
                #jd = s.generate_jobs(test, s.valid_systems(test, jd['series-name']), jd)
                jd = s.generate_jobs(test, jd['systems'], jd)
            except KeyError:
                cdebug('KeyError Exception for %s' % test)


        if jd['fs-benchmarks']:
            jd['tests'] = ['ubuntu_fs_fio_perf']
            for test in jd['tests']:
                cdebug('test: %s' % test, 'blue')
                s.generate_jobs(test, s.valid_systems('Filesystem Benchmarking', jd['series-name']), jd)

        cleave('TheApp::from_tests_generate_jobs')

    # generate_jobs
    #
    def generate_jobs(s, test, systems, jd):
        center('TheApp::generate_jobs')

        if 'package' in jd and 'linux-lts-' in jd['package']:
            jd['series-name'] = jd['package'].replace('linux-lts-', '')
            jd['hwe'] = True

        for system in systems:
            cdebug('system: %s' % system, 'blue')
            for arch in jd['arches']:
                if arch in s.configuration['systems'][system]['arch']:
                    cdebug('arch: %s' % arch, 'blue')
                    job = s.generate_individual_job(test, arch, system, jd)
                    jd['jobs'].append({
                        'system'    : system,
                        'arch'      : arch,
                        'test'      : test,
                        'name'      : job['job-name'],
                        'timestamp' : job['timestamp'],
                    })

        cleave('TheApp::generate_jobs')
        return jd

    # load_template
    #
    def load_template(self, file_name):
        """
        Load the template file.
        """
        center('TheApp::load_template')
        retval = None

        if file_name[0] == '/' or file_name[0] == '.':
            # The full path is specified. Use the name as is.
            #
            fid = file_name
        else:
            # Find it ...
            #
            fid = file_name
            if not os.path.exists(fid):  # Current directory
                fid = os.path.join(os.path.dirname(sys.argv[0]), file_name)
                if not os.path.exists(fid):
                    fid = None

        if fid is not None:
            with open(fid, 'r') as f:
                retval = Template(f.read())
        else:
            print("Error: Failed to find the template file.")

        cleave('TheApp::load_template')
        return retval

    # generate_individual_job
    #
    def generate_individual_job(s, test, arch, system, jd):
        center('TheApp::generate_individual_job')

        job_data = copy.deepcopy(jd)
        job_name = s.job_name(job_data, arch, system, test)

        job_data['job-name'] = job_name
        job_data['sut-arch'] = arch
        job_data['sut-name'] = system
        job_data['test']     = test
        job_data['description'] = json.dumps(job_data, sort_keys=True, indent=4)
        job_data['timestamp'] = date_to_string(datetime.utcnow())

        try:
            job_xml = s.job_template.render(data=job_data)

            with open('/tmp/jenkins.xml', 'w') as f:
                f.write(job_xml)

        except:
            traceback = RichTraceback()
            for (filename, lineno, function, line) in traceback.traceback:
                print("File %s, line %s, in %s" % (filename, lineno, function))
                for s in line:
                    sys.stdout.write(s)
            print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))
            raise

        try:
            s.jenkins.delete_job(job_name)
        except:
            pass

        s.jenkins.create_job(job_name, job_xml)
        sleep(10)
        s.jenkins.build_job(job_name)
        cdebug('created jenkins job: %s' % job_name)
        cleave('TheApp::generate_individual_job')
        return job_data

    # dump
    #
    def _dump(s, d, title=None):
        if s.args.debug:
            if title:
                cdebug(title)
                cdebug('-------------------------------------------------------------------------------------------')
            cdebug('    {')
            for k in d:
                cdebug('        %s : %s,' % (k, d[k]))
            cdebug('    }')

    # _handler
    #
    def _handler(s, payload):
        center('TheApp::_handler')

        s.dyno()  # Reload the configuration and any other relevant files

        valid_key = False
        valid_keys = ['kernel.testing.request', 'kernel.publish', 'kernel-publish.ppa']
        if s.args.lkp:
            valid_keys.append('kernel.testing.livekernelpatching.request')
            valid_keys.append('livepatch.publish')
        elif s.args.dev:
            valid_keys.append('kdev.testing.request')
            valid_keys.append('kdev.testing.livekernelpatching.request')
        for key in valid_keys:
            if payload['key'].startswith(key):
                valid_key = True
                break
        if not valid_key:
            cleave('TheApp::_handler')
            return

        jd = copy.deepcopy(s.job_defaults)  # Job Description (jd)

        # Anything / everything in the payload overrides the defaults.
        #
        for k in payload:
            jd[k] = payload[k]    # Generated by the request, copied as is.

        # Fixup anything that might be missing from the payload that is
        # required for creating a job.
        #
        for k in ['tests', 'systems', 'arches']:  # Order of this list is significant
            cdebug('Fixing %s' % k)
            if k not in jd:
                if 'arches' == k:
                    jd['arches'] = []
                    for system in jd['systems']:
                        for a in s.configuration['systems'][system]['arch']:
                            if a not in jd['arches']:
                                jd['arches'].append(a)
                                cdebug('appending : %s' % a)

                if 'systems' == k:
                    if 'request' == jd['op']:
                        jd['systems'] = s.valid_systems('Personal Testing', jd['series-name'])
                        jd['decoration'] = None
                    else:
                        for t in jd['tests']:
                            for system in s.valid_systems(t, jd['series-name']):
                                try:
                                    jd['systems'].append(system)
                                except KeyError:
                                    jd['systems'] = [system]
                                cdebug('appending : %s' % system)

                if 'tests' == k:
                    if 'sru' == jd['op']:
                        jd['tests'] = SRU_TestsList
                    elif 'boot' == jd['op']:
                        jd['tests'] = BOOT_TestsList
                    else:
                        if s.args.lkp:
                            if jd['op'] == 'livepatch-regression-test':
                                jd['tests'] = LKP_TestsList
                            elif jd['op'] == 'livepatch-snappy-client-payload-test':
                                jd['tests'] = LivepatchSnappyClientPayloadTests
                        else:
                            jd['tests'] = ['default']

                    # Filesystem benchmark tests are handled specially
                    #
                    if 'ubuntu_fs_fio_perf' in jd['tests']:
                        jd['fs-benchmarks'] = True
                        jd['tests'].remove('ubuntu_fs_fio_perf')

                    cdebug('Tests: %s' % jd['tests'])

        if s.args.lkp:
            if jd['key'].startswith('livepatch.'):
                s.handle_request(jd)
        else:
            if jd['key'] == 'kernel.testing.request' or jd['key'].startswith('kdev'):
                # This is a test request from an individual, not from any part of the automated
                # system (shankbot).
                #
                s.handle_request(jd)
            elif jd['key'].startswith('kernel.publish'):
                # This *is* a notification from shankbot that a new kernel is available for testing.
                #
                if jd['pocket'] in ['proposed', 'ppa']:
                    if jd['package'] not in s.package_blacklist:
                        s.handle_kernel_publish(jd)
            else:
                # Just ignore any payload keys we don't recognize. kernel.testing.kernel.completed is
                # an example.
                #
                pass

        cleave('TheApp::_handler')

    # valid_systems
    #
    def valid_systems(s, key, series):
        retval = []
        try:
            for system in s.sut_pool[key]:
                try:
                    if series in s.configuration['systems'][system]['series-blacklist']:
                        continue
                except KeyError:
                    pass
                retval.append(system)
        except KeyError:
            pass
        return retval

    # main
    #
    def main(s):
        '''
        '''
        center('TheApp::main')
        retval = 1

        try:
            if args.local:
                s.mq = MsgQueue(address='localhost', port=9123)
            else:
                s.mq = MsgQueue()
            if s.args.lkp:
                queue = 'livepatch-monitor'
                s.mq.listen(queue, 'livepatch.#', s._handler)
            elif s.args.dev:
                queue = 'kdev-publishing-monitor'
                s.mq.listen(queue, 'kdev.#', s._handler)
            else:
                queue = 'kernel-publishing-monitor'
                s.mq.listen(queue, 'kernel.#', s._handler)

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            warning("Aborting ...")

        except Exit:
            print("")
            print("Due to the above error(s), this script is unable to continue and is terminating.")
            print("")

        cleave('TheApp::main')
        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    app_epilog = '''
examples:
    jc --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--local', action='store_true', default=False, help='Assume we have sshuttle setup to the MQ server.')
    parser.add_argument('--lkp',   action='store_true', default=False, help='Handle requests for live kernel patching testing.')
    parser.add_argument('--dev',   action='store_true', default=False, help='Handle development testing requests.')

    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:
