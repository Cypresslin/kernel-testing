#!/usr/bin/env python
#

import sys
import os
import copy
from time                               import sleep
from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, info, warning, DEBUG, INFO
from lib.msgq                           import MsgQueue
from lib.configuration                  import Configuration
from lib.testsprops                     import SRU_TestsList
from lib.shell                          import sh
from lib.log                            import cdebug, center, cleave
import json

from mako.template                      import Template
from mako.exceptions                    import RichTraceback
from lib.jenkins                        import Jenkins

# Exit
#
class Exit():
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# TheApp
#
class TheApp():
    '''
    This class is just the engine that makes everything go.
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.args = args
        s.jenkins_url_default = "http://kernel-jenkins.kernel:8080"
        s.jenkins = Jenkins(s.jenkins_url_default)
        s.job_defaults = {
            'key'            : 'kernel.testing.request',
            'who'            : None,
            'op'             : 'bogus',
            'date'           : '1960.11.02_08.00.00',
            'hwe'            : False,
            'ppa'            : None,
            'url'            : None,
            'decoration'     : None,
            'fs-benchmarks'  : None,
        }

        # Create a dictionary of the lab HW keyed by role.
        #
        s.sut_pool = {}
        for sut in Configuration['systems']:
            role = Configuration['systems'][sut]['role']

            try:
                s.sut_pool[role].append(sut)
            except:
                s.sut_pool[role] = []
                s.sut_pool[role].append(sut)

        s.jjc = os.path.dirname(sys.argv[0])
        s.jjc = os.path.join(s.jjc, 'jenkins-job-creator', 'jjc')

        if s.args.debug:
            cdebug(json.dumps(s.sut_pool, sort_keys=True, indent=4))

        s.job_template = s.load_template('standard-jenkins-test-job.mako')

        # A list of the packages that we don't test.
        #
        s.package_blacklist = [
            'linux-keystone',
            'linux-armadaxp',
            'linux-ec2',
            'linux-exynos5',
            'linux-ti-omap4',
        ]

    # job_name
    #
    def job_name(s, jd, arch, system):
        center('TheApp::job_name')
        retval = ""

        # The job name starts with some form of the test name(s)
        #
        tests = jd['tests']
        if len(tests) == 1:
            retval += tests[0]
            retval += '__'
        else:
            retval += '-'.join(tests)
            retval = retval.replace('ubuntu', 'u')
            retval += '__'

        retval += jd['series-name'].title()[0]  # Only want the first character
        if jd['hwe']:
            retval += '-hwe'

        if 'series-decoration' in jd and jd['series-decoration'] is not None:
            retval += '_%s' % jd['series-decoration']

        retval += '_%s__using_%s' % (arch, system)

        if jd['who'] is not None:
            retval += '__for_%s' % '_'.join(jd['who'])

        cleave('TheApp::job_name')
        return retval

    # handle_request
    #
    def handle_request(s, jd):
        center('TheApp::handle_request')
        s._dump(jd)

        s.from_tests_generate_jobs(jd)

        cleave('TheApp::handle_request')

    # handle_kernel_publish
    #
    def handle_kernel_publish(s, jd):
        center('TheApp::handle_kernel_publish')
        s._dump(jd)

        jd['series-decoration'] = 'SRU'
        jd['who'] = None

        s.from_tests_generate_jobs(jd)

        cleave('TheApp::handle_kernel_publish')

    # from_tests_generate_jobs
    #
    def from_tests_generate_jobs(s, jd):
        center('TheApp::from_tests_generate_jobs')

        for test in jd['tests']:
            cdebug('test: %s' % test, 'blue')
            s.generate_jobs(test, jd['systems'], jd)

        if jd['fs-benchmarks']:
            jd['tests'] = ['ubuntu_fs_fio_perf']
            for test in jd['tests']:
                cdebug('test: %s' % test, 'blue')
                s.generate_jobs(test, s.valid_systems('Filesystem Benchmarking', jd['series-name']), jd)

        cleave('TheApp::from_tests_generate_jobs')

    # generate_jobs
    #
    def generate_jobs(s, test, systems, jd):
        center('TheApp::generate_jobs')

        if 'linux-lts-' in jd['package']:
            jd['series-name'] = jd['package'].replace('linux-lts-','')
            jd['hwe'] = True

        for system in systems:
            cdebug('system: %s' % system, 'blue')
            for arch in jd['arches']:
                cdebug('arch: %s' % arch, 'blue')
                s.generate_individual_job(test, arch, system, jd)

        cleave('TheApp::generate_jobs')

    # load_template
    #
    def load_template(self, file_name):
        """
        Load the template file.
        """
        center('TheApp::load_template')
        retval = None

        if file_name[0] == '/' or file_name[0] == '.':
            # The full path is specified. Use the name as is.
            #
            fid = file_name
        else:
            # Find it ...
            #
            fid = file_name
            if not os.path.exists(fid): # Current directory
                fid = os.path.join(os.path.dirname(sys.argv[0]), file_name)
                if not os.path.exists(fid):
                    fid = None

        if fid is not None:
            with open(fid, 'r') as f:
                retval = Template(f.read())
        else:
            print("Error: Failed to find the template file.")

        cleave('TheApp::load_template')
        return retval

    # generate_individual_job
    #
    def generate_individual_job(s, test, arch, system, jd):
        center('TheApp::generate_individual_job')

        job_data = copy.deepcopy(jd)
        job_name = s.job_name(job_data, arch, system)

        job_data['job-name'] = job_name
        job_data['sut-arch'] = arch
        job_data['sut-name'] = system
        job_data['test']     = test
        job_data['description'] = json.dumps(job_data, sort_keys=True, indent=4)

        try:
            job_xml = s.job_template.render(data=job_data)

            with open('/tmp/jenkins.xml', 'w') as f:
                f.write(job_xml)

        except:
            traceback = RichTraceback()
            for (filename, lineno, function, line) in traceback.traceback:
                print("File %s, line %s, in %s" % (filename, lineno, function))
                for s in line:
                    sys.stdout.write(s)
            print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))
            raise

        try:
            s.jenkins.delete_job(job_name)
        except:
            pass

        s.jenkins.create_job(job_name, job_xml)
        sleep(10)
        s.jenkins.build_job(job_name)
        warning('created jenkins job: %s' % job_name)
        cleave('TheApp::generate_individual_job')

    # dump
    #
    def _dump(s, d, title=None):
        if s.args.debug:
            if title:
                cdebug(title)
                cdebug('-------------------------------------------------------------------------------------------')
            cdebug('    {')
            for k in d:
                cdebug('        %s : %s,' % (k, d[k]))
            cdebug('    }')

    # _handler
    #
    def _handler(s, payload):
        center('TheApp::_handler')

        valid_key = False
        for key in ['kernel.testing.request', 'kernel.publish']:
            if payload['key'].startswith(key):
                valid_key = True
                break
        if not valid_key:
            info("Ignoring : %s" % payload['key'])
            cleave('TheApp::_handler')
            return

        jd = copy.deepcopy(s.job_defaults)  # Job Description (jd)

        # Anything / everything in the payload overrides the defaults.
        #
        for k in payload:
            jd[k] = payload[k]    # Generated by the request, copied as is.

        # Fixup anything that might be missing from the payload that is
        # required for creating a job.
        #
        for k in ['tests', 'systems', 'arches']: # Order of this list is significant
            cdebug('Fixing %s' % k)
            if k not in jd:
                if 'arches' == k:
                    jd['arches'] = []
                    for sys in jd['systems']:
                        for a in Configuration['systems'][sys]['arch']:
                            if a not in jd['arches']:
                                jd['arches'].append(a)
                                cdebug('appending : %s' % a)

                if 'systems' == k:
                    if 'sru' == jd['op']:
                        jd['systems'] = s.valid_systems('SRU Testing', jd['series-name'])
                        if 'ubuntu_fs_fio_perf' in jd['tests']:
                            for system in s.valid_systems('Filesystem Benchmarking', jd['series-name']):
                                jd['systems'].append(system)
                                cdebug('appending : %s' % system)
                    elif 'request' == jd['op']:
                        jd['systems'] = s.valid_systems('Personal Testing', jd['series-name'])
                        jd['decoration'] = None

                if 'tests' == k:
                    if 'sru' == jd['op']:
                        jd['tests'] = SRU_TestsList
                    else:
                        jd['tests'] = ['default']

                    # Filesystem benchmark tests are handled specially
                    #
                    if 'ubuntu_fs_fio_perf' in jd['tests']:
                        jd['fs-benchmarks'] = True
                        jd['tests'].remove('ubuntu_fs_fio_perf')

        cdebug(' arches: %s' % str(jd['arches']))
        cdebug('systems: %s' % str(jd['systems']))
        cdebug('  tests: %s' % str(jd['tests']))


        if jd['key'] == 'kernel.testing.request':
            # This is a test request from an individual, not from any part of the automated
            # system (shankbot).
            #
            s.handle_request(jd)
        elif jd['key'].startswith('kernel.publish'):
            # This *is* a notification from shankbot that a new kernel is available for testing.
            #
            if 'proposed' in jd['pocket']:
                if jd['package'] not in s.package_blacklist:
                    s.handle_kernel_publish(jd)
        else:
            # Just ignore any payload keys we don't recognize. kernel.testing.kernel.completed is
            # an example.
            #
            pass

        cleave('TheApp::_handler')

    # valid_systems
    #
    def valid_systems(s, key, series):
        retval = []
        for system in s.sut_pool[key]:
            try:
                if series in Configuration['systems'][system]['series-blacklist']: continue
            except KeyError:
                pass
            retval.append(system)
        return retval

    # create_test_jobs
    #
    def create_test_jobs(s, series, arches, systems, url=None, user=None, tests='default', series_decoration=None, hwe=False, ppa=None):
        retval = None
        for arch in arches:
            for system in systems:
                if 'ubuntu_fs_fio_perf' == tests:
                    if 'scratch drive' not in Configuration['systems'][system]:
                        continue
                if arch not in Configuration['systems'][system]['arch']: continue

                cmd = s.jjc + ' --sut=real --hw=%s --sut-arch=%s --sut-series=%s --jenkins-url=%s --test=%s' % (system, arch, series, s.jenkins_url_default, tests)
                if series_decoration is not None:
                    cmd += ' --sut-series-decoration=%s' % series_decoration
                if url is not None:
                    cmd += ' --debs=%s' % (url)
                if user is not None:
                    cmd += ' --user=%s' % (user)
                if hwe:
                    cmd += ' --sut-hwe'
                if ppa:
                    cmd += ' --ppa=%s' % (ppa)
                (return_code, output) = sh(cmd, quiet=False)
                if retval is None: retval = []
                for line in output:
                    line = line.strip()
                    if 'created jenkins job:' in line:
                        (x, job) = line.split('job:', 1)
                        retval.append(job.strip())

        return retval

    # main
    #
    def main(s):
        '''
        '''
        center('TheApp::main')
        retval = 1

        try:
            if args.local:
                mq = MsgQueue(address='localhost', port=9123)
            else:
                mq = MsgQueue()
            mq.listen('kernel-publishing-monitor', 'kernel.#', s._handler)

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            warning("Aborting ...")

        except Exit:
            print("")
            print("Due to the above error(s), this script is unable to continue and is terminating.")
            print("")

        cleave('TheApp::main')
        return retval

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    app_epilog = '''
examples:
    jc --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--local', action='store_true', default=False, help='Assume we have sshuttle setup to the MQ server.')

    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:

