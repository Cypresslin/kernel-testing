#!/usr/bin/env python
#

from os                                 import environ
from lib.argparse                       import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, DEBUG, WARNING
from time                               import sleep

from lib.shell                          import sh, ShellError, ShellTimeoutError
from lib.log                            import cdebug, Clog, cerror
from lib.configuration                  import Configuration
from lib.dlipower                       import PowerSwitch

# Timeout
#
class Timeout(Exception):
    """
    A task took longer than the specified timeout.
    """
    pass

# ErrorExit
#
class ErrorExit(Exception):
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# MetalProvisioner
#
class MetalProvisioner():

    # __init__
    #
    def __init__(s):
        s.quiet = False

    # cycle_power
    #
    def cycle_power(s, target):
        '''
        Has the smarts on how to go about turning the power off to a server
        remotely and then turning it back on. In some cases, multiple ports
        must be power cycled.
        '''
        if not s.quiet:
            print('Cycling the power on \'%s\'' % (target))

        t = LabHW[target]

        if 'ipmi' in t:
            for state in ['off', 'on']:
                cmd = "ipmitool -H %s -I lanplus -U %s -P %s power %s" % (t['ipmi']['ip'], t['ipmi']['username'], t['ipmi']['passwd'], state)
                print(cmd)
                result, output = sh(cmd, ignore_result=False)

                if state == 'off':
                    sleep(60) # Some of the systems want a little delay
                              # between being powered off and then back on.
        else:
            # Power cycle the system so it will netboot and install
            #
            for state in ['off', 'on']:
                for psu in t['cdu']:
                    if psu['ip'] != '':
                        try:
                            ssh('%s@%s' % ('kernel', t['orchestra server']), 'fence_cdu -a %s -l kernel -p K3rn3! -n %s -o %s' % (psu['ip'], psu['port'], state), quiet=True)
                        except ShellError as e:
                            # Sometimes the call to the orchestra server will time-out (not sure why), just
                            # wait a minute and try again.
                            #
                            sleep(60)
                            if not s.quiet:
                                print('    Initial power cycle attempt failed, trying a second time.')
                            ssh('%s@%s' % ('kernel', t['orchestra server']), 'fence_cdu -a %s -l kernel -p K3rn3! -n %s -o %s' % (psu['ip'], psu['port'], state), quiet=True)

                if state == 'off':
                    sleep(60) # Some of the systems want a little delay
                              # between being powered off and then back on.

# Power
#
class Power():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args

    # on
    #
    def on(s, target):
        pass

    # off
    #
    def off(s, target):
        pass

    # cycle
    #
    def cycle(s, target):
        pass

    def amt(s, target, password, cmd):
        cdebug("        Enter: Power::amt")

        output = None
        environ['AMT_PASSWORD'] = password
        cmd = 'amttool %s %s' % (target, cmd)
        cdebug('        CMD: \'%s\'' % cmd)

        # I've seen the amttool command fail to connect some times, just sleep a little and try again.
        # Try 3 times before giving up.
        #
        count = 1
        while True:
            try:
                result, output = sh(cmd, ignore_result=False, quiet=True)
                for l in output:
                    cdebug("        Line: \'%s\'" % l.strip())
                break
            except ShellError as e:
                if count == 3:
                    for line in e.output:
                        cerror(line.rstrip())
                    break
                count += 1
                sleep(5)

        cdebug("        Leave: Power::amt")
        return output

    # status
    #
    def status(s, target):
        cdebug("    Enter: Power::main")
        for p in Configuration['systems'][target]['power']:
            cdebug(p)

            if p['type'] == 'amt':
                output = s.amt(p['address'], p['password'], 'info')
                for l in output:
                    if 'Powerstate:' in l:
                        state = l.split('(')[1].replace(')', '').strip()

            if p['type'] == 'dli':
                switch = PowerSwitch(hostname=p['address'], userid=p['user'], password=p['password'])
                state = switch[p['outlet']].state

            if p['type'] == 'ipmi':
                cmd = "ipmitool -H %s -I lanplus -U %s -P %s power status" % (p['address'], p['user'], p['password'])
                result, output = sh(cmd, ignore_result=False, quiet=True)
                for l in output:
                    cdebug("        Line: \'%s\'" % l.strip())

            if p['type'] == 'cdu':
                cmd('fence_cdu -a %s -l %s -p %s -n %s -o %s' % (p['address'], p['user'], p['password'], p['port'], state))
                result, output = sh(cmd, ignore_result=False, quiet=True)
                for l in output:
                    cdebug("        Line: \'%s\'" % l.strip())

            print(state)
        cdebug("    Leave: Power::main")

    # main
    #
    def main(s):
        cdebug("Enter: Power::main")
        retval = 1
        try:
            target = s.args.target[0] # One target
            action = s.args.action[0] # One action

            if action == 'status':
                s.status(target)

            #metal = None
            #metal = MetalProvisioner()
            #metal.cycle_power(target)

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Aborting ...")

        except ShellTimeoutError as e:
            cerror('The command (%s) timed out. (%d)' % (e.cmd, e.timeout))

        except ShellError as e:
            cerror('The command (%s) returned a non-zero exit status (%d).' % (e.cmd, e.returncode))
            for line in e.output:
                cerror(line.rstrip())

        except ErrorExit:
            pass

        if retval > 0:
            cerror("")
            cerror("Due to the above error(s), this script is unable to continue and is terminating.")
            cerror("")

        cdebug("Leave: Power::main")
        return retval

if __name__ == '__main__':
    app_description = '''
    '''

    app_epilog = '''
    '''

    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug', action='store_true', default=False, help='Print out lots of stuff.')
    parser.add_argument('target', metavar='TARGET', type=str, nargs=1, help='The name of the system to be provisioned.')
    parser.add_argument('action', metavar='ACTION', type=str, nargs=1, help='on | off | cycle | status')

    args = parser.parse_args()

    if args.debug:
        level = DEBUG
        Clog.dbg = True
    else:
        level = WARNING
    basicConfig(filename=None, level=level, format="%(levelname)s - %(message)s")

    app = Power(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab syntax=python:
