#!/usr/bin/env python
#

from os                                 import environ
from lib.argparse                       import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, DEBUG, WARNING
from time                               import sleep

from lib.shell                          import sh, ShellError, ShellTimeoutError
from lib.log                            import cdebug, Clog, cerror
from lib.configuration                  import Configuration
from lib.dlipower                       import PowerSwitch

# Timeout
#
class Timeout(Exception):
    """
    A task took longer than the specified timeout.
    """
    pass

# ErrorExit
#
class ErrorExit(Exception):
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# MetalProvisioner
#
class MetalProvisioner():

    # __init__
    #
    def __init__(s):
        s.quiet = False

    # cycle_power
    #
    def cycle_power(s, target):
        '''
        Has the smarts on how to go about turning the power off to a server
        remotely and then turning it back on. In some cases, multiple ports
        must be power cycled.
        '''
        if not s.quiet:
            print('Cycling the power on \'%s\'' % (target))

        t = LabHW[target]

        if 'ipmi' in t:
            for state in ['off', 'on']:
                cmd = "ipmitool -H %s -I lanplus -U %s -P %s power %s" % (t['ipmi']['ip'], t['ipmi']['username'], t['ipmi']['passwd'], state)
                print(cmd)
                result, output = sh(cmd, ignore_result=False)

                if state == 'off':
                    sleep(60) # Some of the systems want a little delay
                              # between being powered off and then back on.
        else:
            # Power cycle the system so it will netboot and install
            #
            for state in ['off', 'on']:
                for psu in t['cdu']:
                    if psu['ip'] != '':
                        try:
                            ssh('%s@%s' % ('kernel', t['orchestra server']), 'fence_cdu -a %s -l kernel -p K3rn3! -n %s -o %s' % (psu['ip'], psu['port'], state), quiet=True)
                        except ShellError as e:
                            # Sometimes the call to the orchestra server will time-out (not sure why), just
                            # wait a minute and try again.
                            #
                            sleep(60)
                            if not s.quiet:
                                print('    Initial power cycle attempt failed, trying a second time.')
                            ssh('%s@%s' % ('kernel', t['orchestra server']), 'fence_cdu -a %s -l kernel -p K3rn3! -n %s -o %s' % (psu['ip'], psu['port'], state), quiet=True)

                if state == 'off':
                    sleep(60) # Some of the systems want a little delay
                              # between being powered off and then back on.

# Power
#
class Power():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args

    # state
    #
    def state(s, target, state):
        cdebug("    Enter: Power::state")
        cdebug('        target: %s' % target)
        cdebug('         state: %s' % state)
        for p in Configuration['systems'][target]['power']:
            cdebug(p)

            if p['type'] == 'amt':
                output = s.amt(p, state)

            if p['type'] == 'dli':
                state = s.dli(p, state)

            if p['type'] == 'ipmi':
                output = s.ipmi(p, state)

            if p['type'] == 'cdu':
                output = s.cdu(p, state)

        cdebug("    Leave: Power::state")

    def amt(s, p, cmd):
        cdebug("        Enter: Power::amt")

        output = None
        environ['AMT_PASSWORD'] = p['password']
        cmd = 'amttool %s %s' % (p['address'], cmd)
        cdebug('            CMD: \'%s\'' % cmd)

        # I've seen the amttool command fail to connect some times, just sleep a little and try again.
        # Try 3 times before giving up.
        #
        count = 1
        while True:
            try:
                result, output = sh(cmd, ignore_result=False, quiet=True)
                for l in output:
                    cdebug("        Line: \'%s\'" % l.strip())
                break
            except ShellError as e:
                if count == 3:
                    for line in e.output:
                        cerror(line.rstrip())
                    break
                count += 1
                sleep(5)

        cdebug("        Leave: Power::amt")
        return output

    def dli(s, p, cmd):
        cdebug("        Enter: Power::dli")
        switch = PowerSwitch(hostname=p['address'], userid=p['user'], password=p['password'])
        if cmd == "status":
            output = switch[p['outlet']].state
        cdebug("        Enter: Power::dli")
        return output

    def ipmi(s, p, cmd):
        cdebug("        Enter: Power::ipmi")
        cdebug('             cmd: %s' % cmd)
        output = None
        username = Configuration[p['profile']]['username']
        password = Configuration[p['profile']]['password']
        cmd = "ipmitool -H %s -I lanplus -U %s -P %s power %s" % (p['address'], username, password, cmd)
        cdebug('            CMD: \'%s\'' % cmd)
        result, output = sh(cmd, ignore_result=False, quiet=True)
        cdebug("        Enter: Power::ipmi")
        return output

    def cdu(s, p, cmd):
        cdebug("        Enter: Power::cdu")
        output = None
        username = Configuration[p['profile']]['username']
        password = Configuration[p['profile']]['password']
        cmd = 'fence_cdu -a %s -l %s -p %s -n %s -o %s' % (p['address'], username, password, p['port'], cmd)
        cdebug('            CMD: \'%s\'' % cmd)
        result, output = sh(cmd, ignore_result=True, quiet=True)
        cdebug("        Enter: Power::cdu")
        return output

    # status
    #
    def status(s, target):
        cdebug("    Enter: Power::status")
        cdebug('        target: %s' % target)
        state = 'unknown'
        for p in Configuration['systems'][target]['power']:
            cdebug(p)

            if p['type'] == 'amt':
                output = s.amt(p, 'info')
                for l in output:
                    if 'Powerstate:' in l:
                        state = l.split('(')[1].replace(')', '').strip()

            if p['type'] == 'dli':
                state = s.dli(p, "status")

            if p['type'] == 'ipmi':
                output = s.ipmi(p, "status")
                state = output[0].strip().replace('Chassis Power is ', '')

            if p['type'] == 'cdu':
                output = s.cdu(p, "status")
                state = output[0].strip().replace('Status: ', '')

            print(state.lower())
        cdebug("    Leave: Power::status")

    # main
    #
    def main(s):
        cdebug("Enter: Power::main")
        retval = 1
        try:
            target = s.args.target[0] # One target
            action = s.args.action[0] # One action

            if action == 'status':
                s.status(target)
            if action == 'off':
                s.state(target, 'off')
            if action == 'on':
                s.state(target, 'on')
            if action == 'cycle':
                s.state(target, "off")
                sleep(60)
                s.state(target, "on")

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Aborting ...")

        except ShellTimeoutError as e:
            cerror('The command (%s) timed out. (%d)' % (e.cmd, e.timeout))

        except ShellError as e:
            cerror('The command (%s) returned a non-zero exit status (%d).' % (e.cmd, e.returncode))
            for line in e.output:
                cerror(line.rstrip())

        except ErrorExit:
            pass

        if retval > 0:
            cerror("")
            cerror("Due to the above error(s), this script is unable to continue and is terminating.")
            cerror("")

        cdebug("Leave: Power::main")
        return retval

if __name__ == '__main__':
    app_description = '''
This script is for working with the power of the test systems. This
talks to the CDU or system administration interface. It does not go
through MAAS.

With this utility you can interogate the current status, change the
state from on to off or off to on.
    '''

    app_epilog = '''
Examples:
    power rizzo status
    power rizzo off
    power rizzo on
    power rizzo cycle
    '''

    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug', action='store_true', default=False, help='Print out lots of stuff.')
    parser.add_argument('target', metavar='TARGET', type=str, nargs=1, help='The name of the system to be provisioned.')
    parser.add_argument('action', metavar='ACTION', type=str, nargs=1, help='on | off | cycle | status')

    args = parser.parse_args()

    if args.debug:
        level = DEBUG
        Clog.dbg = True
    else:
        level = WARNING
    basicConfig(filename=None, level=level, format="%(levelname)s - %(message)s")

    app = Power(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab syntax=python:
