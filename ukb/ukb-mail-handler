#!/usr/bin/env python
#

from os                                 import getenv, path
from sys                                import exit, stdin
from logging                            import debug, info, error, basicConfig, DEBUG, WARNING, INFO
from lib.argparse                       import ArgumentParser, RawDescriptionHelpFormatter
from lib.configuration                  import Configuration
from lib.testsprops                     import SRU_TestsList
from lib.ubuntu                         import Ubuntu
from email                              import Parser as EmailParser
from re                                 import search
from lib.shell                          import sh, ShellError
import json

import smtplib
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText

# ErrorExit
#
class ErrorExit(Exception):
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# MailHandler
#
class MailHandler():
    """
    """

    # __init__
    #
    def __init__(s, args):
        s.args = args
        s.jenkins_url_default = "http://10.245.80.32:8080"
        s.default_arches=['amd64', 'i386', 'ppc64el']

        # Create a dictionary of the lab HW keyed by role.
        #
        s.sut_pool = {}
        for sut in Configuration['systems']:
            role = Configuration['systems'][sut]['role']

            try:
                s.sut_pool[role].append(sut)
            except:
                s.sut_pool[role] = []
                s.sut_pool[role].append(sut)

    # send_reply
    #
    def send_reply(s, to, subject, body):
        guser = s.cfg['email username']
        gpass = s.cfg['email password']

        msg = MIMEMultipart()
        msg['From'] = guser
        msg['To']   = to + ", Brad Figg <brad.figg@canonical.com>"
        msg['Subject'] = subject

        # Add a standard signature to each message
        #
        body += '\n--\nUbuntu Kernel Bot ubuntu.kernel.bot@gmail.com'
        msg.attach(MIMEText(body))

        gsrvr = smtplib.SMTP('smtp.gmail.com', 587)
        gsrvr.ehlo()
        gsrvr.starttls()
        gsrvr.ehlo()
        gsrvr.login(guser, gpass)
        gsrvr.sendmail(guser, msg['To'], msg.as_string())
        gsrvr.close()

    # create_test_jobs
    #
    def create_test_jobs(s, series, arches, systems, url=None, user=None, tests='default', series_decoration=None, hwe=False, ppa=None):
        retval = []
        for arch in arches:
            for system in systems:
                if arch in Configuration['systems'][system]['arch']:
                    cmd = '/home/work/kernel-testing/jenkins-job-creator/jjc --sut=real --hw=%s --sut-arch=%s --sut-series=%s --jenkins-url=%s --test=%s' % (system, arch, series, s.jenkins_url_default, tests)
                    if series_decoration is not None:
                        cmd += ' --sut-series-decoration=%s' % series_decoration
                    if url is not None:
                        cmd += ' --debs=%s' % (url)
                    if user is not None:
                        cmd += ' --user=%s' % (user)
                    if hwe:
                        cmd += ' --sut-hwe'
                    if ppa:
                        cmd += ' --ppa=%s' % (ppa)
                    debug('  ' + cmd)
                    print(cmd)
                    (return_code, output) = sh(cmd, quiet=False)
                    for line in output:
                        line = line.strip()
                        if 'created jenkins job:' in line:
                            (x, job) = line.split('job:', 1)
                            retval.append(job.strip())

        return retval

    # handle_test_request
    #
    def handle_test_request(s, msg):
        debug('    Enter: handle_test_request')

        e_from = msg['From']
        e_subject = msg['Subject']

        # In a kernel test request email, there is a line that specifies the series
        # that is to be tested and a url to the debs to be tested.
        #
        #    series: <series>
        #    url: <url>
        #
        for part in msg.walk():
            series = None
            debs_url = None
            ppa = None
            arches = s.default_arches
            systems = s.sut_pool['Personal Testing']
            tests = 'default'
            send_help = False
            hwe = False
            for line in part.get_payload().split('\n'):
                line = line.strip()
                print line
                if search('series\s*:', line) is not None:
                    (x, series) = line.split(':')
                    series = series.strip()
                elif search('url\s*:', line) is not None:
                    (x, debs_url) = line.split(':', 1)
                    debs_url = debs_url.strip()
                elif search('arch\s*:', line) is not None:
                    (x, arch) = line.split(':', 1)
                    arches = []
                    for a in arch.split(','):
                        arches.append(a.strip())
                elif search('tests\s*:', line) is not None:
                    (x, tests) = line.split(':', 1)
                    tests = tests.strip()
                    if 'fs_fio_perf' in tests:
                        systems = s.sut_pool['Filesystem Benchmarking']
                elif search('system\s*:', line) is not None:
                    (x, system) = line.split(':', 1)
                    system = system.strip()
                    systems = []
                    for a in system.split(','):
                        systems.append(a.strip())
                elif search('ppa\s*:', line) is not None:
                    (x, ppa) = line.split(':', 1)
                    ppa = ppa.strip()
                elif search('hwe\s*:\s*[Tt]rue', line) is not None:
                    hwe = True
                    print("i spy hwe")
                elif 'help' == line or 'Help' == line:
                    send_help = True

            break # Only want to do one part

        body = ''
        if not send_help: #if (series is not None) and (debs_url is not None):
            jobs = None
            try:
                user = 'bogus'
                m = search('.*<(\S+)@.*', e_from)
                if m is not None:
                    user = m.group(1)
                jobs = s.create_test_jobs(series, arches, systems, debs_url, user, tests, ppa=ppa, hwe=hwe)

                body  = 'The following job(s) were created on the kernel team\'s jenkins server\n'
                body += 'in response to your request:\n\n'

                if jobs is not None:
                    info('The following jenkins jobs were created for %s' % user)
                    for job in jobs:
                        body += '      %s\n' % job
                        info('    %s' % job)

            except ShellError as e: # This should probably be an exception specific to job creation.
                body  = 'The following error occured while trying to create the test jobs that\n'
                body += 'you requested:\n\n'

                for line in e.output:
                    body += '      ' + line

            s.send_reply(e_from, 'Re: %s' % e_subject, body)
        else:
            info('Help sent to: %s' % e_from)
            if send_help:
                body = """
The subject of the email message must be "Subject: Kernel Test Request".

The body of the email message should be a simple set of "name":"value" pairs,
one per line. The following describe the recognized pairs:

series: The ubuntu series that is initially installed onto the test system
        prior to installing the custom kernel deps. This is the only option
        that is required.

        Ex.
            series: precise

  arch: The architecture of the kernel to be tested. This can be a comma separated
        list of architectures or a single one. If not spcified, both amd64 and i386
        architectures are tested.

        Ex.
            arch: amd64

        Ex.
            arch: amd64, i386

 tests: The list of autotest tests that are to be run on the system. If none
        are specified, then the 'default' is used. At this time 'default' is:
            ubuntu_ecryptfs, ubuntu_qrt_kernel_hardening, ubuntu_qrt_kernel_panic,
            ubuntu_qrt_kernel_security, ubuntu_qrt_kernel_aslr_collisions,
            ubuntu_qrt_apparmor

        Ex.
            tests: ubuntu_qrt_apparmor

   url: The URL to the directory containing the custom kernel debs to be installed
        and tested on the system under test.

        Ex.
            url: http://kernel.ubuntu.com/~bradf/precise-lp111666

system: The name of the lab system that is to be used for the testing. The
        default is 'waldorf, beaker, rizzo'. In general, you shouldn't do
        this unless you know what other test systems are being used for.

        Ex.
            system: gonzo

   ppa: The ppa to get target .deb packages from

       Ex.
           ppa: canonical-kernel-team/ppa

   hwe: The test request is for a HWE kernel (lts-backport).

       Ex.
           hwe: True
"""
                s.send_reply(e_from, 'Re: %s' % e_subject, body)

        debug('    Leave: handle_test_request')

    # handle_mainline_build
    #
    def handle_mainline_build(s, msg):
        debug('    Enter: handle_mainline_build')

        # In the standard email announcing a mainline build, the first URL
        # is to the location of the debs.
        #
        debs_url = None
        for part in msg.walk():
            for line in part.get_payload().split('\n'):
                line = line.strip()
                if 'http://kernel.ubuntu.com' in line:
                    debs_url = line
                    break
            break # Only want to do one part


        if debs_url is not None:
            # The URL contains the version which also contains the series
            # name of the configuration that it was built with. Use that.
            #
            parts = debs_url.split('/')
            version = parts[len(parts) - 2]
            tmp = version.split('-')
            series = tmp[len(tmp) - 1]
            series_decoration = '-'.join(tmp[:-1])
            arches = s.default_arches
            systems = s.default_systems

            jobs = s.create_test_jobs(series, arches, systems, debs_url, 'mainline.builder', series_decoration=series_decoration, tests='mainline')
            if jobs is not None:
                info('The following jenkins jobs were created for mainline.builder')
                for job in jobs:
                    info('    %s' % job)

        debug('    Leave: handle_mainline_build')

    # handle_sru_kernel_uploaded
    #
    def handle_sru_kernel_uploaded(s, series, msg):
        debug('    Enter: handle_sru_kernel_uploaded')

        # Only development kernels are done this way now.
        #
        if Ubuntu().is_development_series(series):
            # If we want certain kernels to be run for certain series.
            #
            tests = SRU_TestsList
            for t in tests:
                if 'ubuntu_fs_fio_perf' in t:
                    jobs = s.create_test_jobs(series, s.default_arches, s.sut_pool['Filesystem Benchmarking'], series_decoration='SRU', tests=t)
                else:
                    jobs = s.create_test_jobs(series, s.default_arches, s.sut_pool['SRU Testing'], series_decoration='SRU', tests=t)
                if jobs is not None:
                    info('The following jenkins jobs were created')
                    for job in jobs:
                        info('    %s' % job)

        debug('    Leave: handle_sru_kernel_uploaded')

    # handle_kernel_uploaded_to_ppa
    #
    def handle_kernel_uploaded_to_ppa(s, msg):
        debug('    Enter: handle_kernel_uploaded_to_ppa')

        props = {}
        for x in msg.get_payload().split('\n'):
            try:
                x = x.strip()
                if x == '': continue

                (k, v) = x.split(':', 1)
                props[k.strip()] = v.strip()
            except:
                # If the line doesn't match our simple parsing, just skip it.
                #
                pass

        if '-lts-' in props['Package']:
            hwe = True
        else:
            hwe = False

        # If we want certain kernels to be run for certain series.
        #
        tests = SRU_TestsList
        for t in tests:
            if 'ubuntu_fs_fio_perf' in t:
                jobs = s.create_test_jobs(props['Series'], s.default_arches, s.sut_pool['Filesystem Benchmarking'], series_decoration='SRU', tests=t, hwe=hwe)
            else:
                jobs = s.create_test_jobs(props['Series'], s.default_arches, s.sut_pool['SRU Testing'], series_decoration='SRU', tests=t, hwe=hwe)
            if jobs is not None:
                info('The following jenkins jobs were created')
                for job in jobs:
                    info('    %s' % job)

        debug('    Leave: handle_kernel_uploaded_to_ppa')

    # handle_hwe_kernel_uploaded
    #
    def handle_hwe_kernel_uploaded(s, series, msg):
        debug('    Enter: handle_hwe_kernel_uploaded')

        tests = SRU_TestsList
        for t in tests:
            if 'iozone' in t:
                jobs = s.create_test_jobs(series, s.default_arches, s.sut_pool['Filesystem Benchmarking'], series_decoration='SRU', tests=t, hwe=True)
            else:
                jobs = s.create_test_jobs(series, s.default_arches, s.sut_pool['SRU Testing'], series_decoration='SRU', tests=t, hwe=True)
            if jobs is not None:
                info('The following jenkins jobs were created')
                for job in jobs:
                    info('    %s' % job)

        debug('    Leave: handle_hwe_kernel_uploaded')

    # main
    #
    def main(s):
        debug('Enter: main')
        retval = 1
        try:
            # Read the configuration file
            #
            cfg_file = path.join(path.expanduser('~'), '.ukb.rc')
            if path.exists(cfg_file):
                with open(cfg_file, 'r') as f:
                    s.cfg = json.load(f)
            else:
                error("The required configuration file (%s) was not found." % cfg_file)
                raise ErrorExit()

            raw_content = stdin.read()
            with open('/tmp/ukb.eml', 'w') as f:
                f.write(raw_content)

            ep = EmailParser.Parser()
            msg = ep.parsestr(raw_content)

            e_from = msg['From']
            e_subject = msg['Subject']

            while True:
                info('[Processing] From: %s    Subject: %s' % (e_from, e_subject))

                # Mainline Build from the mainline builder
                #
                #if 'Mainline Build' in e_subject:
                #    s.handle_mainline_build(msg)
                #    break

                if 'kernel test request' in e_subject.lower():
                    s.handle_test_request(msg)
                    break

                m = search('(.*) available in ppa', e_subject.lower())
                if m is not None:
                    info('  - New kernel in PPA')
                    s.handle_kernel_uploaded_to_ppa(msg)
                    break

                m = search('\[(\S+)\] linux \d+\.\d+\.\d+.* uploaded', e_subject.lower())
                if m is not None:
                    s.handle_sru_kernel_uploaded(m.group(1), msg)
                    break

                m = search('\[\S+\] linux-lts-backport-(\S+) \d+\.\d+\.\d+.* uploaded', e_subject.lower())
                if m is not None:
                    s.handle_hwe_kernel_uploaded(m.group(1), msg)
                    break

                m = search('\[\S+\] linux-lts-(\S+) \d+\.\d+\.\d+.* uploaded', e_subject.lower())
                if m is not None:
                    s.handle_hwe_kernel_uploaded(m.group(1), msg)
                    break

                info('  - ignored')
                debug('Unhandled email')
                break

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except ErrorExit:
            error("")
            error("Due to the above error(s), this script is unable to continue and is terminating.")
            error("")

        except:
            error("An unhandled exception occurred.")
            raise

        debug('Leave: main')
        return(retval)

if __name__ == '__main__':
    if getenv('DEBUG'):
        LOGLEVEL = DEBUG
    else:
        LOGLEVEL = WARNING
    LOGLEVEL = INFO
    LOGFILE  = '/var/log/ukb/ukb-mail-handler.log'
    basicConfig(filename=LOGFILE, level=LOGLEVEL, format="%(asctime)s %(levelname)s - %(message)s")
    info('ukb-mail-handler Invoked')

    app_description = '''
    '''

    app_epilog = '''
    '''

    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    args = parser.parse_args()

    app = MailHandler(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab syntax=python:
