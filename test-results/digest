#!/usr/bin/env python
#
# Take a tree of test results and process it, producing a set of html
# reports.
#

from sys                                import argv
from getopt                             import getopt, GetoptError
from datetime                           import datetime
from os                                 import path

from mako.template                      import Template
from mako.exceptions                    import RichTraceback

from grinder                            import CmdlineError, Exit, TestResultsRepository, TestResultsRepositoryError, load_template
from lib.dbg                            import Dbg
from lib.utils                          import error, stdo, dump, string_to_date, json_load

from lib.ubuntu                         import Ubuntu
from lib.debian                         import Debian

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error("%s\n" % e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo("    Usage:                                                                                   \n")
        stdo("        %s [<options>]                                                                       \n" % defaults['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("                         Recognized debug options:                                           \n")
        stdo("                             enter                                                           \n")
        stdo("                             leave                                                           \n")
        stdo("                             verbose                                                         \n")
        stdo("                             cfg                                                             \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s --debug=\"enter,leave,verbose\"                                                   \n" % defaults['app_name'])

    # process
    #
    def process(self, argv, defaults):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        result = True
        try:
            cfg = defaults

            optsShort = ''
            optsLong  = ['help', 'debug=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif opt in ('--debug'):
                    cfg['debug'] = val.split(',')
                    for level in cfg['debug']:
                        if level not in Dbg.levels:
                            Dbg.levels.append(level)

        except GetoptError, error:
            raise CmdlineError(error)

        return cfg

# Digest
#
class Digest():
    """
    """

    # __init__
    #
    def __init__(self, cfg):
        Dbg.enter("Digest.__init__")

        self.cfg = cfg
        self.cfg['template'] = 'digest-index.mako'

        Dbg.leave("Digest.__init__")

    # initialize
    #
    def initialize(self):
        Dbg.enter("Digest.initialize")

        try:
            self.trr = TestResultsRepository()
            self.ubuntu = Ubuntu()

            self.index_template = Template(load_template(self.cfg['template']))
            self.host_template = Template(load_template('host.mako'))

            self.hosts_info = json_load(path.join(path.dirname(argv[0]), 'hosts.json'))

        except TestResultsRepositoryError as e:
            error(e.msg)
            Dbg.leave("Digest.initialize")
            raise Exit()

        Dbg.leave("Digest.initialize")

    # series
    #
    def series(self, results):
        Dbg.enter("Digest.series")

        retval = "unknown"
        try:
            # First see if the series is in the results. This might have been done by hand
            # to add a series where this algorithm doesn't work.
            #
            retval = results['attributes']['series']
        except KeyError:
            kv = ''
            try:
                kv = results['attributes']['kernel']
                m = Debian.version_rc.match(kv)
                if m:
                    for s in Ubuntu.index_by_series_name:
                        if s in kv:
                            # If the series is in the kernel version string, it is most likely
                            # a "backport" kernel and we should use the series in the version
                            #
                            retval = s
                            break

                    if retval == 'unknown':
                        version = '%s.0' % (m.group(1)) # Only want major and minor for determining the series
                        retval = self.ubuntu.lookup(version)['name']
                else:
                    print(" ** WARNING: The kernel version string found in the results data did not match the regex.")
            except KeyError:
                print(" ** WARNING: The kernel version (%s) did not match up with any Ubuntu series." % (results['attributes']['kernel']))

        Dbg.leave("Digest.series")
        return retval

    # main
    #
    def main(self):
        Dbg.enter("Digest.main")

        try:
            self.initialize()

            # Build the data dictionary that will be passed into the mako template renderer.
            #
            data = {}
            for tr in self.trr.test_runs:
                results = self.trr.results(tr)
                #dump(results['attributes'])
                Dbg.verbose("%s\n" % (tr))
                Dbg.verbose("    kernel: %s\n" % (results['attributes']['kernel']))

                series = self.series(results)
                results['attributes']['series'] = series
                Dbg.verbose("    series: %s\n" % (series))

                # "Fixup" the timestamp to be what we want it to look like on the web page
                #
                ts = string_to_date(results['attributes']['timestamp'])
                results['attributes']['timestamp'] = ts.strftime("%Y-%m-%d %H:%M")

                # The primary key is the series.
                #
                if series not in data:
                    data[series] = {}

                # If the kernel used was a "custom" kernel, one that someone on the kernel
                # team built themselves or a mainline build kernel, we want that information
                #
                job = results['attributes']['environ']['JOB_NAME']
                who = None
                if '_for_' in job:
                    (junk, who) = job.split('_for_')

                if who is not None:
                    print("who: %s" % who)

                # The secondary key for 'data' is the kernel version.
                #
                k = results['attributes']['kernel']
                if who is not None:
                    k = k + '&nbsp;&nbsp;(%s)' % who
                if k not in data[series]:
                    data[series][k] = []
                data[series][k].append(results)

            #dump(data)


            # Generate the testing, index page.
            #
            try:
                template = self.index_template.render(data = data, timestamp = datetime.utcnow())
                dest = path.join(self.trr.cfg['repository_root'], 'index.html')
                with open(dest, 'w') as f:
                    f.write(template)

                for host in self.hosts_info:
                    template = self.host_template.render(data = self.hosts_info[host], title = host, timestamp = datetime.utcnow())
                    dest = path.join(self.trr.cfg['repository_root'], '%s.html' % host)
                    with open(dest, 'w') as f:
                        f.write(template)

            except:
                traceback = RichTraceback()
                for (filename, lineno, function, line) in traceback.traceback:
                    print("File %s, line %s, in %s" % (filename, lineno, function))
                    print(line, "\n")
                print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        except TestResultsRepositoryError as e:
            error(e.msg)
            Dbg.leave("Digest.main")
            raise Exit()

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except Exit:
            pass

        Dbg.leave("Digest.main")
        return


if __name__ == '__main__':
    defaults = {}
    defaults['app_name'] = argv[0]

    # The cmdline processing is done here partially so the debug options
    # can be processed right away.
    #
    cmdline = Cmdline()
    try:
        app = Digest(cmdline.process(argv, defaults))
        app.main()
    except CmdlineError as e:
        cmdline.error(e.msg, defaults)

# vi:set ts=4 sw=4 expandtab:

