#!/usr/bin/env python
#

from sys                                import argv
from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG, info
from lib.log                            import cdebug, Clog, cerror
from datetime                           import datetime
from os                                 import path, makedirs

from mako.template                      import Template
from mako.exceptions                    import RichTraceback

from lib.grinder                        import Exit, TestResultsRepository, TestResultsRepositoryError, load_template
from lib.dbg                            import Dbg
from lib.utils                          import error, dump, string_to_date, json_load

from lib.ubuntu                         import Ubuntu
from lib.debian                         import Debian

import json
import requests
import re


# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.cfg = {}
        s.cfg['template'] = 'digest-index.mako'
        s.args = args

    # initialize
    #
    def initialize(self):
        cdebug("Enter Digest.initialize")

        try:
            self.trr = TestResultsRepository(rc='test-results.rc')
            self.ubuntu = Ubuntu()

            self.host_template = Template(load_template('host.mako'))

            self.index_template = Template(load_template('digest-index.mako'))
            self.alt_index_template = Template(load_template('alt-index.mako'))
            self.workflow_index_template = Template(load_template('workflow-index.mako'))
            self.suite_index_template = Template(load_template('suite-index.mako'))

            self.hosts_info = json_load(path.join(path.dirname(argv[0]), 'hosts.json'))

        except TestResultsRepositoryError as e:
            error(e.msg)
            cdebug("Leave Digest.initialize")
            raise Exit()

        cdebug("Leave Digest.initialize")

    # series
    #
    def series(self, results):
        cdebug("    Enter Digest.series")

        retval = "unknown"
        try:
            # First see if the series is in the results. This might have been done by hand
            # to add a series where this algorithm doesn't work.
            #
            retval = results['attributes']['series']
        except KeyError:
            kv = ''
            try:
                kv = results['attributes']['kernel']
                m = Debian.version_rc.match(kv)
                if m:
                    for s in Ubuntu.index_by_series_name:
                        #cdebug("        series: " + s)
                        if s in kv:
                            cdebug("            is backport kernel", 'blue')
                            # If the series is in the kernel version string, it is most likely
                            # a "backport" kernel and we should use the series in the version
                            #
                            retval = s
                            break

                    if retval == 'unknown':
                        # Starting with Utopic we are adding the series version to the kernel version and not
                        # the series name.
                        #
                        for k in Ubuntu.db:
                            if '~%s' % k in kv:
                                cdebug("            is backport kernel", 'blue')
                                # If the series is in the kernel version string, it is most likely
                                # a "backport" kernel and we should use the series in the version
                                #
                                retval = Ubuntu.db[k]['name']
                                break

                    if retval == 'unknown':
                        # What a hack ...
                        if '2.6' == m.group(1):
                            version = '2.6.32'
                        else:
                            version = '%s.0' % (m.group(1)) # Only want major and minor for determining the series
                        retval = self.ubuntu.lookup(version)['name']
                else:
                    print(" ** WARNING: The kernel version string found in the results data did not match the regex.")
            except KeyError:
                print(" ** WARNING: The kernel version (%s) did not match up with any Ubuntu series." % (results['attributes']['kernel']))

        cdebug("    Leave Digest.series (%s)" % retval)
        return retval

    def generate_hybrid_results_index(self, data):
        cdebug("Enter Digest.generate_hybrid_results_index")

        # Take the cumulative results dictionary and build a test-suite focused dictionary from
        # it.
        #
        cdebug('--------------------------------------------------')
        hybrid = {} # suite results
        cdebug('Building test-suite focused dictionary')
        for series in data['sru']:
            cdebug('    series: %s' % series)
            if series not in hybrid:
                hybrid[series] = {}

            for kver in data['sru'][series]:
                cdebug('        kver: %s' % kver)
                if kver not in hybrid[series]:
                    hybrid[series][kver] = {}

                for test_run in data['sru'][series][kver]:
                    attributes = test_run['attributes']

                    # decode the arch
                    #
                    machine = attributes['platform']['machine']
                    proc    = attributes['platform']['proc']
                    if proc == 'x86_64':
                        arch = 'amd64'
                    elif proc == 'i686':
                        arch = 'i386'
                    elif proc == 'athlon':
                        arch = 'i386'
                    elif proc == 'aarch64':
                        arch = 'arm64'
                    else:
                        arch = proc

                    if arch not in hybrid[series][kver]:
                        hybrid[series][kver][arch] = {}

                    results = test_run['results']
                    for k in results['suites']:
                        suite = k['name'].replace('autotest.', '')

                        link = '%s/%s-%s-%s-index.html' % (kver, suite, kver, arch)

                        if suite not in hybrid[series][kver][arch]:
                            if suite == 'qrt_apparmor':
                                cdebug("            %s : new (%s); ran: %d; failed: %d" % (suite, arch, k['tests run'], k['tests failed']), 'green')
                            hybrid[series][kver][arch][suite] = {}
                            hybrid[series][kver][arch][suite]['link'] = link
                            hybrid[series][kver][arch][suite]['failed']  = k['tests failed']
                            hybrid[series][kver][arch][suite]['run']     = k['tests run']
                            hybrid[series][kver][arch][suite]['skipped'] = k['tests skipped']
                        else:
                            if suite == 'qrt_apparmor':
                                cdebug("            %s : adding (%s); ran: %d; failed: %d" % (suite, arch, k['tests run'], k['tests failed']), 'green')
                            hybrid[series][kver][arch][suite]['failed']  += k['tests failed']
                            hybrid[series][kver][arch][suite]['run']     += k['tests run']
                            hybrid[series][kver][arch][suite]['skipped'] += k['tests skipped']

        # Generate the testing, index page.
        #
        try:
            cdebug('Generating: hybrid-index.html')
            template = self.alt_index_template.render(data = hybrid, timestamp = datetime.utcnow())
            dest = path.join(self.trr.cfg['repository_root'], 'index.html')
            with open(dest, 'w') as f:
                f.write(template)

        except:
            traceback = RichTraceback()
            for (filename, lineno, function, line) in traceback.traceback:
                print("File %s, line %s, in %s" % (filename, lineno, function))
                print(line, "\n")
            print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        cdebug("Leave Digest.generate_hybrid_results_index")

    def generate_tracker_results_index(self, data):
        '''
        '''
        cdebug("Enter Digest.generate_tracker_results_index")

        #                              .- package name (group(1))
        #                             /           .- kernel version (group(2))
        #                            /           /          .- version/abi separator (group(3))
        #                           /           /          /
        ver_rc     = re.compile("(\S+): (\d+\.\d+\.\d+)([-\.])(\d+)\.(\d+)([~a-z\d.]*)")
        #                                                       /      /       /
        #                                                      /      /       .- backport extra (m.group(6))
        #                                                     /      .- upload number (m.group(5))
        #                                                    .- abi (group(4))

        versions = []
        r = requests.get('http://kernel.ubuntu.com/sru/kernel-sru-workflow.json')
        trackers = json.loads(r.text)

        for project in ['kernel-development-workflow', 'kernel-sru-workflow']:
            for x in trackers['bug-collections'][project]['bugs']:
                bug = trackers['bug-collections'][project]['bugs'][x]
                title = bug['title']

                m = ver_rc.search(title)
                if m is not None:
                    version = '%s%s%s.%s%s' % (m.group(2), m.group(3), m.group(4), m.group(5), m.group(6))
                    versions.append(version)

        for v in sorted(versions):
            print(v)
        print('------------------------------------------------------------------------------------')

        # Take the cumulative results dictionary and build a test-suite focused dictionary from
        # it.
        #
        cdebug('--------------------------------------------------')
        hybrid = {} # suite results
        cdebug('Building test-suite focused dictionary')
        for series in data['sru']:
            cdebug('    series: %s' % series)
            if series not in hybrid:
                hybrid[series] = {}

            for kver in data['sru'][series]:
                cdebug('        kver: %s' % kver)
                if kver not in hybrid[series]:
                    hybrid[series][kver] = {}

                for test_run in data['sru'][series][kver]:
                    attributes = test_run['attributes']

                    # decode the arch
                    #
                    machine = attributes['platform']['machine']
                    proc    = attributes['platform']['proc']
                    if proc == 'x86_64':
                        arch = 'amd64'
                    elif proc == 'i686':
                        arch = 'i386'
                    elif proc == 'athlon':
                        arch = 'i386'
                    elif proc == 'aarch64':
                        arch = 'arm64'
                    else:
                        arch = proc

                    if arch not in hybrid[series][kver]:
                        hybrid[series][kver][arch] = {}

                    results = test_run['results']
                    for k in results['suites']:
                        suite = k['name'].replace('autotest.', '')

                        link = '%s/%s-%s-%s-index.html' % (kver, suite, kver, arch)

                        if suite not in hybrid[series][kver][arch]:
                            if suite == 'qrt_apparmor':
                                cdebug("            %s : new (%s); ran: %d; failed: %d" % (suite, arch, k['tests run'], k['tests failed']), 'green')
                            hybrid[series][kver][arch][suite] = {}
                            hybrid[series][kver][arch][suite]['link'] = link
                            hybrid[series][kver][arch][suite]['failed']  = k['tests failed']
                            hybrid[series][kver][arch][suite]['run']     = k['tests run']
                            hybrid[series][kver][arch][suite]['skipped'] = k['tests skipped']
                        else:
                            if suite == 'qrt_apparmor':
                                cdebug("            %s : adding (%s); ran: %d; failed: %d" % (suite, arch, k['tests run'], k['tests failed']), 'green')
                            hybrid[series][kver][arch][suite]['failed']  += k['tests failed']
                            hybrid[series][kver][arch][suite]['run']     += k['tests run']
                            hybrid[series][kver][arch][suite]['skipped'] += k['tests skipped']

        # Generate the testing, index page.
        #
        try:
            cdebug('Generating: hybrid-index.html')
            template = self.workflow_index_template.render(data = hybrid, timestamp = datetime.utcnow(), versions=versions)
            dest = path.join(self.trr.cfg['repository_root'], 'tracker-index.html')
            with open(dest, 'w') as f:
                f.write(template)

        except:
            traceback = RichTraceback()
            for (filename, lineno, function, line) in traceback.traceback:
                print("File %s, line %s, in %s" % (filename, lineno, function))
                print(line, "\n")
            print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        cdebug("Leave Digest.generate_tracker_results_index")

    def generate_per_suite_indexes(self, data):
        cdebug('--------------------------------------------------')
        sr = {} # suite results
        cdebug('Building test-suite focused dictionary')
        for series in data['sru']:
            cdebug('    series: %s' % series)
            for kver in data['sru'][series]:
                cdebug('        kver: %s' % kver)
                for test_run in data['sru'][series][kver]:
                    attributes = test_run['attributes']

                    # decode the arch
                    #
                    hostname = attributes['platform']['hostname']
                    machine  = attributes['platform']['machine']
                    proc     = attributes['platform']['proc']
                    if proc == 'x86_64':
                        arch = 'amd64'
                    elif proc == 'i686':
                        arch = 'i386'
                    elif proc == 'athlon':
                        arch = 'i386'
                    elif proc == 'aarch64':
                        arch = 'arm64'
                    else:
                        arch = proc

                    dt = datetime.strptime(attributes['timestamp'], '%Y-%m-%d %H:%M')
                    ts = dt.strftime('%Y-%m-%d_%H-%M-%S')

                    results = test_run['results']
                    for k in results['suites']:
                        suite = k['name'].replace('autotest.', '')

                        if suite not in sr:
                            sr[suite] = {}

                        if kver not in sr[suite]:
                            sr[suite][kver] = {}

                        if arch not in sr[suite][kver]:
                            sr[suite][kver][arch] = {}

                        if ts not in sr[suite][kver][arch]:
                            sr[suite][kver][arch][ts] = {}

                        if suite == 'qrt_apparmor':
                            cdebug("            New: %s %s %s %s %s" % (suite, kver, arch, ts, hostname), 'green')
                            #cdebug("            %s : new (%s); ran: %d; failed: %d" % (suite, arch, k['tests run'], k['tests failed']), 'green')

                        sr[suite][kver][arch][ts][hostname] = {}
                        sr[suite][kver][arch][ts][hostname]['failed']  = k['tests failed']
                        sr[suite][kver][arch][ts][hostname]['ran']     = k['tests run']
                        sr[suite][kver][arch][ts][hostname]['passed']  = k['tests run'] - k['tests failed']

                        link = "http://kernel.ubuntu.com/testing/%s/%s__%s__%s/%s-test-suite.html" % (kver, hostname, kver, ts, suite)
                        sr[suite][kver][arch][ts][hostname]['link'] = link

                        sr[suite][kver][arch][ts][hostname]['timestamp'] = attributes['timestamp']


        for suite in sr:
            cdebug('suite: %s' % suite)
            for kver in sr[suite]:
                cdebug('    kver: %s' % kver)
                for arch in sr[suite][kver]:
                    cdebug('    arch: %s' % arch)

                    xs = suite.replace('autotest.', '')
                    fname = '%s-%s-%s-index.html' % (suite.replace('autotest.', ''), kver, arch)
                    # Generate the testing, index page.
                    #
                    try:
                        cdebug('Generating: %s' % fname)
                        p = path.join(self.trr.cfg['repository_root'], kver)
                        if not path.exists(p):
                            makedirs(p)

                        template = self.suite_index_template.render(suite=xs, kver=kver, arch=arch, data=sr[suite][kver][arch], timestamp = datetime.utcnow())
                        dest = path.join(self.trr.cfg['repository_root'], kver, fname)
                        with open(dest, 'w') as f:
                            f.write(template)

                    except:
                        traceback = RichTraceback()
                        for (filename, lineno, function, line) in traceback.traceback:
                            print("File %s, line %s, in %s" % (filename, lineno, function))
                            print(line, "\n")
                        print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

    # main
    #
    def main(self):
        cdebug("Enter Digest.main")

        try:
            self.initialize()

            # Build the data dictionary that will be passed into the mako template renderer.
            #
            data = {}
            for tr in self.trr.test_runs:
                try:
                    cdebug('tr: %s' % tr)
                    results = self.trr.results(tr)
                except TestResultsRepositoryError as e:
                    error(e.msg)
                    continue

                cdebug("Processing: %s" % (tr), 'green')
                cdebug("    kernel: %s" % (results['attributes']['kernel']))

                # If the kernel used was a "custom" kernel, one that someone on the kernel
                # team built themselves or a mainline build kernel, we want that information
                #
                job = results['attributes']['environ']['JOB_NAME']
                who = None
                if '_for_' in job:
                    (junk, who) = job.split('_for_')
                    cdebug("       who: %s" % (who))
                else:
                    who = 'sru'

                if who not in data:
                    data[who] = {}

                series = self.series(results)
                results['attributes']['series'] = series
                cdebug("    series: %s" % (series))

                # "Fixup" the timestamp to be what we want it to look like on the web page
                #
                ts = string_to_date(results['attributes']['timestamp'])
                results['attributes']['timestamp'] = ts.strftime("%Y-%m-%d %H:%M")

                # The primary key is the series.
                #
                if series not in data[who]:
                    data[who][series] = {}

                # The secondary key for 'data' is the kernel version.
                #
                k = results['attributes']['kernel']
                if k not in data[who][series]:
                    data[who][series][k] = []
                data[who][series][k].append(results)


            self.generate_hybrid_results_index(data)
            self. generate_tracker_results_index(data)
            self.generate_per_suite_indexes(data)

            # Generate the testing, index page.
            #
            try:
                cdebug('Generating: index.html')
                template = self.index_template.render(data = data['sru'], timestamp = datetime.utcnow())
                dest = path.join(self.trr.cfg['repository_root'], 'clasic-index.html')
                with open(dest, 'w') as f:
                    f.write(template)

                for k in data:
                    cdebug('Generating: %s-index.html' % k)
                    template = self.index_template.render(data = data[k], timestamp = datetime.utcnow())
                    dest = path.join(self.trr.cfg['repository_root'], '%s-index.html' % k)
                    with open(dest, 'w') as f:
                        f.write(template)

                for host in self.hosts_info:
                    template = self.host_template.render(data = self.hosts_info[host], title = host, timestamp = datetime.utcnow())
                    dest = path.join(self.trr.cfg['repository_root'], '%s.html' % host)
                    with open(dest, 'w') as f:
                        f.write(template)

            except:
                traceback = RichTraceback()
                for (filename, lineno, function, line) in traceback.traceback:
                    print("File %s, line %s, in %s" % (filename, lineno, function))
                    print(line, "\n")
                print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        except TestResultsRepositoryError as e:
            error(e.msg)
            cdebug("Leave Digest.main")
            raise Exit()

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except Exit:
            pass

        cdebug("Leave Digest.main")
        return

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    app_epilog = '''
examples:
    process --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--nc', action='store_true', default=False, help='Debut output should not be colored.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
        Clog.dbg = True
        Clog.color = not args.nc
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:

