#!/usr/bin/env python
#

from sys                                import argv
from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG
from lib.log                            import cdebug, Clog
from datetime                           import datetime
from os                                 import path, makedirs

from mako.template                      import Template
from mako.exceptions                    import RichTraceback

from lib.grinder                        import Exit, TestResultsRepository, TestResultsRepositoryError, load_template
from lib.utils                          import error, string_to_date, json_load

from lib.ubuntu                         import Ubuntu
from lib.debian                         import Debian

import json
import requests
import re


# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.cfg = {}
        s.cfg['template'] = 'digest-index.mako'
        s.args = args

    # initialize
    #
    def initialize(self):
        cdebug("Enter Digest.initialize")

        try:
            self.trr = TestResultsRepository(rc='test-results.rc')
            self.ubuntu = Ubuntu()

        except TestResultsRepositoryError as e:
            error(e.msg)
            cdebug("Leave Digest.initialize")
            raise Exit()

        cdebug("Leave Digest.initialize")

    # series
    #
    def series(self, results):
        cdebug("    Enter Digest.series")

        retval = "unknown"
        try:
            # First see if the series is in the results. This might have been done by hand
            # to add a series where this algorithm doesn't work.
            #
            retval = results['attributes']['series']
        except KeyError:
            kv = ''
            try:
                kv = results['attributes']['kernel']
                m = Debian.version_rc.match(kv)
                if m:
                    for s in Ubuntu.index_by_series_name:
                        if s in kv:
                            cdebug("            is backport kernel", 'blue')
                            # If the series is in the kernel version string, it is most likely
                            # a "backport" kernel and we should use the series in the version
                            #
                            retval = s
                            break

                    if retval == 'unknown':
                        # Starting with Utopic we are adding the series version to the kernel version and not
                        # the series name.
                        #
                        for k in Ubuntu.db:
                            if '~%s' % k in kv:
                                cdebug("            is backport kernel", 'blue')
                                # If the series is in the kernel version string, it is most likely
                                # a "backport" kernel and we should use the series in the version
                                #
                                retval = Ubuntu.db[k]['name']
                                break

                    if retval == 'unknown':
                        # What a hack ...
                        if '2.6' == m.group(1):
                            version = '2.6.32'
                        else:
                            version = '%s.0' % (m.group(1)) # Only want major and minor for determining the series
                        retval = self.ubuntu.lookup(version)['name']
                else:
                    print(" ** WARNING: The kernel version string found in the results data did not match the regex.")
            except KeyError:
                print(" ** WARNING: The kernel version (%s) did not match up with any Ubuntu series." % (results['attributes']['kernel']))

        cdebug("    Leave Digest.series (%s)" % retval)
        return retval

    # arch_from_proc
    #
    def arch_from_proc(s, proc):
        if proc == 'x86_64':
            arch = 'amd64'
        elif proc == 'i686':
            arch = 'i386'
        elif proc == 'athlon':
            arch = 'i386'
        elif proc == 'aarch64':
            arch = 'arm64'
        else:
            arch = proc
        return arch

    def per_suite_results(self, data):
        # Take the cumulative results dictionary and build a test-suite focused dictionary from
        # it.
        #
        cdebug('--------------------------------------------------')
        retval = {} # suite results
        cdebug('Building test-suite focused dictionary')
        for series in data['sru']:
            cdebug('    series: %s' % series)
            if series not in retval:
                retval[series] = {}

            for kver in data['sru'][series]:
                cdebug('        kver: %s' % kver)
                if kver not in retval[series]:
                    retval[series][kver] = {}

                for test_run in data['sru'][series][kver]:
                    attributes = test_run['attributes']

                    # decode the arch
                    #
                    arch = self.arch_from_proc(attributes['platform']['proc'])

                    if arch not in retval[series][kver]:
                        retval[series][kver][arch] = {}

                    results = test_run['results']
                    for k in results['suites']:
                        suite = k['name'].replace('autotest.', '')

                        link = '%s/%s-%s-%s-index.html' % (kver, suite, kver, arch)

                        if suite not in retval[series][kver][arch]:
                            if suite == 'qrt_apparmor':
                                cdebug("            %s : new (%s); ran: %d; failed: %d" % (suite, arch, k['tests run'], k['tests failed']), 'green')
                            retval[series][kver][arch][suite] = {}
                            retval[series][kver][arch][suite]['link'] = link
                            retval[series][kver][arch][suite]['failed']  = k['tests failed']
                            retval[series][kver][arch][suite]['run']     = k['tests run']
                            retval[series][kver][arch][suite]['skipped'] = k['tests skipped']
                        else:
                            if suite == 'qrt_apparmor':
                                cdebug("            %s : adding (%s); ran: %d; failed: %d" % (suite, arch, k['tests run'], k['tests failed']), 'green')
                            retval[series][kver][arch][suite]['failed']  += k['tests failed']
                            retval[series][kver][arch][suite]['run']     += k['tests run']
                            retval[series][kver][arch][suite]['skipped'] += k['tests skipped']
        return retval

    def generate_hybrid_results_index(self, data):
        cdebug("Enter Digest.generate_hybrid_results_index")

        hybrid = self.per_suite_results(data)

        # Generate the testing, index page.
        #
        try:
            cdebug('Generating: hybrid-index.html')
            alt_index_template = Template(load_template('alt-index.mako'))
            template = alt_index_template.render(data=hybrid, timestamp=datetime.utcnow())
            dest = path.join(self.trr.cfg['repository_root'], 'index.html')
            with open(dest, 'w') as f:
                f.write(template)

        except:
            traceback = RichTraceback()
            for (filename, lineno, function, line) in traceback.traceback:
                print("File %s, line %s, in %s" % (filename, lineno, function))
                print(line, "\n")
            print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        cdebug("Leave Digest.generate_hybrid_results_index")

    def generate_tracker_results_index(self, data):
        '''
        '''
        cdebug("Enter Digest.generate_tracker_results_index")

        #                              .- package name (group(1))
        #                             /           .- kernel version (group(2))
        #                            /           /          .- version/abi separator (group(3))
        #                           /           /          /
        ver_rc     = re.compile("(\S+): (\d+\.\d+\.\d+)([-\.])(\d+)\.(\d+)([~a-z\d.]*)")
        #                                                       /      /       /
        #                                                      /      /       .- backport extra (m.group(6))
        #                                                     /      .- upload number (m.group(5))
        #                                                    .- abi (group(4))

        versions = []
        r = requests.get('http://kernel.ubuntu.com/sru/kernel-sru-workflow.json')
        trackers = json.loads(r.text)

        for project in ['kernel-development-workflow', 'kernel-sru-workflow']:
            if project not in trackers['bug-collections']:
                continue
            for x in trackers['bug-collections'][project]['bugs']:
                bug = trackers['bug-collections'][project]['bugs'][x]
                title = bug['title']

                m = ver_rc.search(title)
                if m is not None:
                    version = '%s%s%s.%s%s' % (m.group(2), m.group(3), m.group(4), m.group(5), m.group(6))
                    versions.append(version)

        hybrid = self.per_suite_results(data)

        # Generate the testing, index page.
        #
        try:
            cdebug('Generating: hybrid-index.html')
            workflow_index_template = Template(load_template('workflow-index.mako'))
            template = workflow_index_template.render(data=hybrid, timestamp=datetime.utcnow(), versions=versions)
            dest = path.join(self.trr.cfg['repository_root'], 'tracker-index.html')
            with open(dest, 'w') as f:
                f.write(template)

        except:
            traceback = RichTraceback()
            for (filename, lineno, function, line) in traceback.traceback:
                print("File %s, line %s, in %s" % (filename, lineno, function))
                print(line, "\n")
            print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        cdebug("Leave Digest.generate_tracker_results_index")

    def generate_per_suite_indexes(self, data):
        cdebug('--------------------------------------------------')
        sr = {} # suite results
        cdebug('Building test-suite focused dictionary')
        for series in data['sru']:
            cdebug('    series: %s' % series)
            for kver in data['sru'][series]:
                cdebug('        kver: %s' % kver)
                for test_run in data['sru'][series][kver]:
                    attributes = test_run['attributes']

                    # decode the arch
                    #
                    hostname = attributes['platform']['hostname']
                    arch = self.arch_from_proc(attributes['platform']['proc'])

                    dt = datetime.strptime(attributes['timestamp'], '%Y-%m-%d %H:%M')
                    ts = dt.strftime('%Y-%m-%d_%H-%M-%S')

                    results = test_run['results']
                    for k in results['suites']:
                        suite = k['name'].replace('autotest.', '')

                        if suite not in sr:
                            sr[suite] = {}

                        if kver not in sr[suite]:
                            sr[suite][kver] = {}

                        if arch not in sr[suite][kver]:
                            sr[suite][kver][arch] = {}

                        if ts not in sr[suite][kver][arch]:
                            sr[suite][kver][arch][ts] = {}

                        if suite == 'qrt_apparmor':
                            cdebug("            New: %s %s %s %s %s" % (suite, kver, arch, ts, hostname), 'green')

                        sr[suite][kver][arch][ts][hostname] = {}
                        sr[suite][kver][arch][ts][hostname]['failed']  = k['tests failed']
                        sr[suite][kver][arch][ts][hostname]['ran']     = k['tests run']
                        sr[suite][kver][arch][ts][hostname]['passed']  = k['tests run'] - k['tests failed']

                        link = "%s__%s__%s/%s-test-suite.html" % (hostname, kver, ts, suite)
                        sr[suite][kver][arch][ts][hostname]['link'] = link

                        sr[suite][kver][arch][ts][hostname]['timestamp'] = attributes['timestamp']

        for suite in sr:
            cdebug('suite: %s' % suite)
            for kver in sr[suite]:
                cdebug('    kver: %s' % kver)
                for arch in sr[suite][kver]:
                    cdebug('    arch: %s' % arch)

                    xs = suite.replace('autotest.', '')
                    fname = '%s-%s-%s-index.html' % (suite.replace('autotest.', ''), kver, arch)
                    # Generate the testing, index page.
                    #
                    try:
                        cdebug('Generating: %s' % fname)
                        p = path.join(self.trr.cfg['repository_root'], kver)
                        if not path.exists(p):
                            makedirs(p)

                        suite_index_template = Template(load_template('suite-index.mako'))
                        template = suite_index_template.render(suite=xs, kver=kver, arch=arch, data=sr[suite][kver][arch], timestamp=datetime.utcnow())
                        dest = path.join(self.trr.cfg['repository_root'], kver, fname)
                        with open(dest, 'w') as f:
                            f.write(template)

                    except:
                        traceback = RichTraceback()
                        for (filename, lineno, function, line) in traceback.traceback:
                            print("File %s, line %s, in %s" % (filename, lineno, function))
                            print(line, "\n")
                        print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

    # collect_results
    #
    def collect_results(self):
        '''
        Build a dictionary of all of the test results.

        dict:
            who:
                series:
                    kernel-version:
                        test results
        '''
        data = {}
        for tr in self.trr.test_runs:
            try:
                cdebug('tr: %s' % tr)
                results = self.trr.results(tr)
            except TestResultsRepositoryError as e:
                error(e.msg)
                continue

            cdebug("Processing: %s" % (tr), 'green')
            cdebug("    kernel: %s" % (results['attributes']['kernel']))

            # If the kernel used was a "custom" kernel, one that someone on the kernel
            # team built themselves or a mainline build kernel, we want that information
            #
            job = results['attributes']['environ']['JOB_NAME']
            who = None
            if '_for_' in job:
                (junk, who) = job.split('_for_')
                cdebug("       who: %s" % (who))
            else:
                who = 'sru' # 'sru' is just a general 'catch all' this lumps everything
                # that wasn't done by someone specifically into a single
                # bucket.

            if who not in data:
                data[who] = {}

            series = self.series(results)
            results['attributes']['series'] = series
            cdebug("    series: %s" % (series))

            # "Fixup" the timestamp to be what we want it to look like on the web page
            #
            ts = string_to_date(results['attributes']['timestamp'])
            results['attributes']['timestamp'] = ts.strftime("%Y-%m-%d %H:%M")

            # The primary key is the series.
            #
            if series not in data[who]:
                data[who][series] = {}

            # The secondary key for 'data' is the kernel version.
            #
            k = results['attributes']['kernel']
            if False:
                if 'livepatch-package-version' in results['attributes']:
                    live = results['attributes']['livepatch-package-version']
                    k = '%s - %s' % (k, live)
            if k not in data[who][series]:
                data[who][series][k] = []
            data[who][series][k].append(results)
        return data

    # main
    #
    def main(self):
        cdebug("Enter Digest.main")

        try:
            self.initialize()

            # Build the data dictionary that will be passed into the mako template renderer.
            #
            data = self.collect_results()

            self.generate_hybrid_results_index(data)
            self.generate_tracker_results_index(data)
            self.generate_per_suite_indexes(data)

            # Generate the testing, index page.
            #
            try:
                cdebug('Generating: index.html')
                index_template = Template(load_template('digest-index.mako'))
                template = index_template.render(data=data['sru'], timestamp=datetime.utcnow())
                dest = path.join(self.trr.cfg['repository_root'], 'clasic-index.html')
                with open(dest, 'w') as f:
                    f.write(template)

                for k in data:
                    cdebug('Generating: %s-index.html' % k)
                    template = index_template.render(data=data[k], timestamp=datetime.utcnow())
                    dest = path.join(self.trr.cfg['repository_root'], '%s-index.html' % k)
                    with open(dest, 'w') as f:
                        f.write(template)

                host_template = Template(load_template('host.mako'))
                hosts_info = json_load(path.join(path.dirname(argv[0]), 'hosts.json'))
                for host in hosts_info:
                    template = host_template.render(data=hosts_info[host], title=host, timestamp=datetime.utcnow())
                    dest = path.join(self.trr.cfg['repository_root'], '%s.html' % host)
                    with open(dest, 'w') as f:
                        f.write(template)

            except:
                traceback = RichTraceback()
                for (filename, lineno, function, line) in traceback.traceback:
                    print("File %s, line %s, in %s" % (filename, lineno, function))
                    print(line, "\n")
                print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        except TestResultsRepositoryError as e:
            error(e.msg)
            cdebug("Leave Digest.main")
            raise Exit()

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except Exit:
            pass

        cdebug("Leave Digest.main")
        return

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    app_epilog = '''
examples:
    process --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--nc', action='store_true', default=False, help='Debut output should not be colored.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
        Clog.dbg = True
        Clog.color = not args.nc
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab:
