#!/usr/bin/env python
#

from sys                                import argv
from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG, info
from lib.log                            import cdebug, Clog, cerror
from datetime                           import datetime
from os                                 import path

from mako.template                      import Template
from mako.exceptions                    import RichTraceback

from lib.grinder                        import Exit, TestResultsRepository, TestResultsRepositoryError, load_template
from lib.dbg                            import Dbg
from lib.utils                          import error, dump, string_to_date, json_load

from lib.ubuntu                         import Ubuntu
from lib.debian                         import Debian


# TheApp
#
class TheApp():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.cfg = {}
        s.cfg['template'] = 'digest-index.mako'
        s.args = args

    # initialize
    #
    def initialize(self):
        cdebug("Enter Digest.initialize")

        try:
            self.trr = TestResultsRepository(rc='test-results.rc')
            self.ubuntu = Ubuntu()

            self.index_template = Template(load_template(self.cfg['template']))
            self.host_template = Template(load_template('host.mako'))

            self.hosts_info = json_load(path.join(path.dirname(argv[0]), 'hosts.json'))

        except TestResultsRepositoryError as e:
            error(e.msg)
            cdebug("Leave Digest.initialize")
            raise Exit()

        cdebug("Leave Digest.initialize")

    # series
    #
    def series(self, results):
        cdebug("    Enter Digest.series")

        retval = "unknown"
        try:
            # First see if the series is in the results. This might have been done by hand
            # to add a series where this algorithm doesn't work.
            #
            retval = results['attributes']['series']
        except KeyError:
            kv = ''
            try:
                kv = results['attributes']['kernel']
                m = Debian.version_rc.match(kv)
                if m:
                    for s in Ubuntu.index_by_series_name:
                        cdebug("        series: " + s)
                        if s in kv:
                            cdebug("            is backport kernel", 'blue')
                            # If the series is in the kernel version string, it is most likely
                            # a "backport" kernel and we should use the series in the version
                            #
                            retval = s
                            break

                    if retval == 'unknown':
                        # Starting with Utopic we are adding the series version to the kernel version and not
                        # the series name.
                        #
                        for k in Ubuntu.db:
                            if '~%s' % k in kv:
                                cdebug("            is backport kernel", 'blue')
                                # If the series is in the kernel version string, it is most likely
                                # a "backport" kernel and we should use the series in the version
                                #
                                retval = Ubuntu.db[k]['name']
                                break

                    if retval == 'unknown':
                        # What a hack ...
                        if '2.6' == m.group(1):
                            version = '2.6.32'
                        else:
                            version = '%s.0' % (m.group(1)) # Only want major and minor for determining the series
                        retval = self.ubuntu.lookup(version)['name']
                else:
                    print(" ** WARNING: The kernel version string found in the results data did not match the regex.")
            except KeyError:
                print(" ** WARNING: The kernel version (%s) did not match up with any Ubuntu series." % (results['attributes']['kernel']))

        cdebug("    Leave Digest.series (%s)" % retval)
        return retval

    # main
    #
    def main(self):
        cdebug("Enter Digest.main")

        try:
            self.initialize()

            # Build the data dictionary that will be passed into the mako template renderer.
            #
            data = {}
            for tr in self.trr.test_runs:
                try:
                    results = self.trr.results(tr)
                except TestResultsRepositoryError as e:
                    error(e.msg)
                    continue

                #dump(results['attributes'])
                cdebug("Processing: %s" % (tr), 'green')
                cdebug("    kernel: %s" % (results['attributes']['kernel']))

                # If the kernel used was a "custom" kernel, one that someone on the kernel
                # team built themselves or a mainline build kernel, we want that information
                #
                job = results['attributes']['environ']['JOB_NAME']
                who = None
                if '_for_' in job:
                    (junk, who) = job.split('_for_')
                    cdebug("       who: %s" % (who))
                else:
                    who = 'sru'

                if who not in data:
                    data[who] = {}

                series = self.series(results)
                results['attributes']['series'] = series
                cdebug("    series: %s" % (series))

                # "Fixup" the timestamp to be what we want it to look like on the web page
                #
                ts = string_to_date(results['attributes']['timestamp'])
                results['attributes']['timestamp'] = ts.strftime("%Y-%m-%d %H:%M")

                # The primary key is the series.
                #
                if series not in data[who]:
                    data[who][series] = {}

                # The secondary key for 'data' is the kernel version.
                #
                k = results['attributes']['kernel']
                if k not in data[who][series]:
                    data[who][series][k] = []
                data[who][series][k].append(results)

            #dump(data)


            # Generate the testing, index page.
            #
            try:
                cdebug('Generating: index.html')
                template = self.index_template.render(data = data['sru'], timestamp = datetime.utcnow())
                dest = path.join(self.trr.cfg['repository_root'], 'index.html')
                with open(dest, 'w') as f:
                    f.write(template)

                for k in data:
                    cdebug('Generating: %s-index.html' % k)
                    template = self.index_template.render(data = data[k], timestamp = datetime.utcnow())
                    dest = path.join(self.trr.cfg['repository_root'], '%s-index.html' % k)
                    with open(dest, 'w') as f:
                        f.write(template)

                for host in self.hosts_info:
                    template = self.host_template.render(data = self.hosts_info[host], title = host, timestamp = datetime.utcnow())
                    dest = path.join(self.trr.cfg['repository_root'], '%s.html' % host)
                    with open(dest, 'w') as f:
                        f.write(template)

            except:
                traceback = RichTraceback()
                for (filename, lineno, function, line) in traceback.traceback:
                    print("File %s, line %s, in %s" % (filename, lineno, function))
                    print(line, "\n")
                print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        except TestResultsRepositoryError as e:
            error(e.msg)
            cdebug("Leave Digest.main")
            raise Exit()

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except Exit:
            pass

        cdebug("Leave Digest.main")
        return

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    app_epilog = '''
examples:
    process --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--nc', action='store_true', default=False, help='Debut output should not be colored.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
        Clog.dbg = True
        Clog.color = not args.nc
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:

