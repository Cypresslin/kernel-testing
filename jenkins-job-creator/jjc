#!/usr/bin/env python
#
# Called by one of the jenkins matix jobs for every cell of
# the matix. This job creates the correct provision-job,
# testing-job combination based on the environment variables
# of the matrix job.
#

from sys                                import stdout, argv, exit
from os                                 import getenv, path
import json
from argparse                           import ArgumentParser
from logging                            import debug, info, basicConfig, DEBUG, INFO
from mako.template                      import Template
from mako.exceptions                    import RichTraceback
from lib.jenkins                        import Jenkins, JenkinsException, LAUNCHER_SSH, LAUNCHER_COMMAND, LAUNCHER_WINDOWS_SERVICE

# load_cfg
#
def load_cfg(file_name):
    """
    Load the configuration file, returning the same as a python object.
    """
    retval = None

    # Find it ...
    #
    fid = file_name
    if not path.exists(fid): # Current directory
        fid = path.join(path.expanduser('~'), file_name)
        if not path.exists(fid): # Users home directory
            fid = path.join(path.dirname(argv[0]), file_name)
            if not path.exists(fid):
                fid = None

    if fid is not None:
        with open(fid, 'r') as f:
            retval = json.load(f)
    else:
        print("Error: Failed to find the configuration file.")

    return retval

# Exit
#
class Exit():
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# InvalidException
#
class InvalidException(Exception):
    def __init__(self, v):
        self.value = v
    def __str__(self):
        return self.value

# InvalidSystemType
#
class InvalidSystemType(InvalidException):
    def __init__(self, v):
        InvalidException.__init__(self, v)

# InvalidKernelArch
#
class InvalidKernelArch(InvalidException):
    def __init__(self, v):
        InvalidException.__init__(self, v)

# InvalidKernelType
#
class InvalidKernelType(InvalidException):
    def __init__(self, v):
        InvalidException.__init__(self, v)

# InvalidSeries
#
class InvalidSeries(InvalidException):
    def __init__(self, v):
        InvalidException.__init__(self, v)

# SutJobsFactory
#
class SutJobsFactory():

    kmap = {
        'orchestra arch' : {
            'amd64' : 'x86_64',
            'i386' : 'i386'
        },
        'series' : {
            'lucid' : {
                'hwe series' : None,
                'preseed' : 'secondary',
                'server distro decoration' : '',
            },
            'natty' : {
                'hwe series' : 'lucid',
                'hwe package' : 'linux-image-generic-lts-backport-natty',
                'preseed' : 'natty',
                'server distro decoration' : '',
            },
            'oneiric' : {
                'hwe series' : 'lucid',
                'hwe package' : 'linux-image-generic-lts-backport-oneiric',
                'preseed' : 'primary',
                'server distro decoration' : '-server',
            },
            'precise' : {
                'hwe series' : None,
                'preseed' : 'primary',
                'server distro decoration' : '-server',
            },
            'quantal' : {
                'hwe series' : 'precise',
                'hwe package' : 'linux-generic-lts-quantal',
                'preseed' : 'primary',
                'server distro decoration' : '-server',
            },
        }
    }

    # __init__
    #
    def __init__(self, args):
        self.cfg = args
        server_url = self.cfg.jenkins_url
        self.jenkins = Jenkins(server_url)

    # load_template
    #
    def load_template(self, file_name):
        """
        Load the template file.
        """
        retval = None

        if file_name[0] == '/' or file_name[0] == '.':
            # The full path is specified. Use the name as is.
            #
            fid = file_name
        else:
            # Find it ...
            #
            fid = file_name
            if not path.exists(fid): # Current directory
                fid = path.join(path.dirname(argv[0]), file_name)
                if not path.exists(fid):
                    fid = None

        if fid is not None:
            with open(fid, 'r') as f:
                retval = Template(f.read())
        else:
            print("Error: Failed to find the template file.")

        return retval

    # create_job
    #
    def create_job(self, job_name, template_name, cfg):
        template = self.load_template(template_name)
        job_xml = template.render(data=cfg)

        try:
            self.jenkins.delete_job(job_name)
        except:
            pass
        self.jenkins.create_job(job_name, job_xml)
        info('created jenkins job: %s' % job_name)

    # bare_metal_sut_jobs
    #
    def bare_metal_sut_jobs(self, cfg):
        '''
        Based on the options specified on the command line, use the appropriate mako
        templates to create a bare-metal provisioning job and a testing job (that will
        run on that newly provisioned system) on the jenkins server. The testing job
        will be started by the provisioning job once the provisioned system comes up.
        '''
        setattr(cfg, 'testing_job_name', '%s-%s-%s-test' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch))
        setattr(cfg, 'provisioning_job_name', '%s-hw-provisioning-%s-%s' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch))

        setattr(cfg, 'sut_orchestra_arch', self.kmap['orchestra arch'][cfg.sut_arch])
        setattr(cfg, 'sut_preseed', self.kmap['series'][cfg.sut_series]['preseed'])
        setattr(cfg, 'sut_server_distro_decoration', self.kmap['series'][cfg.sut_series]['server distro decoration'])

        if cfg.sut_hwe:
            cfg.testing_job_name = '%s-lts-%s-%s-test' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch)
            cfg.provisioning_job_name = '%s-hw-provisioning-lts-%s-%s' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch)
            setattr(cfg, 'sut_hwe_series', cfg.sut_series)
            setattr(cfg, 'sut_hwe_package', self.kmap['series'][cfg.sut_series]['hwe package'])
            cfg.sut_series = self.kmap['series'][cfg.sut_series]['hwe series']

        if not cfg.no_test:
            self.create_job(cfg.testing_job_name, cfg.tt, cfg)

        if not cfg.no_provisioning:
            self.create_job(cfg.provisioning_job_name, 'hw-provisioning-job.mako', cfg)

        if not cfg.no_autostart:
            if not cfg.no_provisioning:
                self.jenkins.build_job(cfg.provisioning_job_name)
            else:
                self.jenkins.build_job(cfg.testing_job_name)

    # virtual_sut_jobs
    #
    def virtual_sut_jobs(self, cfg):
        '''
        Very similar to the 'bare_metal_sut_jobs' method above, this creates 3
        jenkins jobs. The first jenkins job provisions the bare-metal system,
        the second provisions a kvm instance on that provisioned bare-metal
        system and the third is the test job which runs on the provisioned kvm.
        '''
        setattr(cfg, 'testing_job_name', '%s-%s-%s_on_%s-%s-test' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch, cfg.vh_series, cfg.vh_arch))
        setattr(cfg, 'vh_provisioning_job_name', '%s-hw4vm-provisioning-%s-%s_%s-%s' % (cfg.vh_name, cfg.vh_series, cfg.vh_arch, cfg.sut_series, cfg.sut_arch))
        setattr(cfg, 'vm_client_provisioning_job_name', '%s-vm-client-provisioning-%s-%s_on_%s-%s' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch, cfg.vh_series, cfg.vh_arch))

        if cfg.vh_hwe:
            if cfg.sut_hwe:
                cfg.testing_job_name = '%s-hwe-%s-%s_on_hwe-%s-%s-test' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch, cfg.vh_series, cfg.vh_arch)
                cfg.vh_provisioning_job_name = '%s-hw4vm-provisioning-hwe-%s-%s_hwe-%s-%s' % (cfg.vh_name, cfg.vh_series, cfg.vh_arch, cfg.sut_series, cfg.sut_arch)
                cfg.vm_client_provisioning_job_name = '%s-vm-client-provisioning-hwe-%s-%s_on_hwe-%s-%s' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch, cfg.vh_series, cfg.vh_arch)
            else:
                cfg.testing_job_name = '%s-%s-%s_on_hwe-%s-%s-test' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch, cfg.vh_series, cfg.vh_arch)
                cfg.vh_provisioning_job_name = '%s-hw4vm-provisioning-hwe-%s-%s_%s-%s' % (cfg.vh_name, cfg.vh_series, cfg.vh_arch, cfg.sut_series, cfg.sut_arch)
                cfg.vm_client_provisioning_job_name = '%s-vm-client-provisioning-%s-%s_on_hwe-%s-%s' % (cfg.sut_name, cfg.sut_series, cfg.sut_arch, cfg.vh_series, cfg.vh_arch)

            setattr(cfg, 'vh_hwe_series', cfg.sut_series)
            setattr(cfg, 'vh_hwe_package', self.kmap['series'][cfg.vh_series]['hwe package'])
            cfg.vh_series = self.kmap['series'][cfg.vh_series]['hwe series']

        setattr(cfg, 'vh_orchestra_arch', self.kmap['orchestra arch'][cfg.vh_arch])
        setattr(cfg, 'vh_preseed', self.kmap['series'][cfg.vh_series]['preseed'])
        setattr(cfg, 'vh_server_distro_decoration', self.kmap['series'][cfg.vh_series]['server distro decoration'])

        if cfg.sut_hwe:
            setattr(cfg, 'sut_hwe_series', cfg.sut_series)
            setattr(cfg, 'sut_hwe_package', self.kmap['series'][cfg.sut_series]['hwe package'])
            cfg.sut_series = self.kmap['series'][cfg.sut_series]['hwe series']

        setattr(cfg, 'sut_orchestra_arch', self.kmap['orchestra arch'][cfg.sut_arch])
        setattr(cfg, 'sut_preseed', self.kmap['series'][cfg.sut_series]['preseed'])
        setattr(cfg, 'sut_server_distro_decoration', self.kmap['series'][cfg.sut_series]['server distro decoration'])

        if not cfg.no_test:
            self.create_job(cfg.testing_job_name, cfg.tt, cfg)

        if not cfg.no_provisioning:
            self.create_job(cfg.vh_provisioning_job_name, 'hw4vm-provisioning-job.mako', cfg)
            self.create_job(cfg.vm_client_provisioning_job_name, cfg.vm_client_template, cfg)

        if not cfg.no_autostart:
            if not cfg.no_provisioning:
                self.jenkins.build_job(cfg.vh_provisioning_job_name)
            else:
                self.jenkins.build_job(cfg.testing_job_name)

    # main
    #
    def main(self):
        retval = 1
        try:
            # Now, actually do something.
            #
            try:
                if self.cfg.sut == 'real':
                    self.bare_metal_sut_jobs(self.cfg)
                else:
                    self.virtual_sut_jobs(self.cfg)
                retval = 0

            except:
                traceback = RichTraceback()
                for (filename, lineno, function, line) in traceback.traceback:
                    print("File %s, line %s, in %s" % (filename, lineno, function))
                    for s in line:
                        stdout.write(s)
                print("%s: %s" % (str(traceback.error.__class__.__name__), traceback.error))

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        return retval


if __name__ == '__main__':

    result = 0

    if getenv('DEBUG'):
        LOGLEVEL = DEBUG
    else:
        LOGLEVEL = INFO
    basicConfig(level=LOGLEVEL, format="%(asctime)-15s-%(levelname)s - %(message)s")
    info('Started')

    hw = load_cfg('hw.db')

    # The purpose is to produce all the individual jenkins jobs to make up
    # a single test. That single test will test a single kernel. There are
    # several combinations that we want to be able to handle.
    #
    # 1. Provision a bare metal system from scratch. Run the standard
    #    kernel tests on it. Support all series Lucid and newer.
    #
    # 2. Provision a bare metal system from scratch. On that, provision
    #    a kvm system from scratch. Again, run the standard kernel tests
    #    on the virtual client. Support all variations of kernel host
    #    and virtual clients.
    #
    # Terms:
    #
    #   sut - (System Under Test). This is the system on which the tests
    #         will be run. If this is a bare-metal system then it is that
    #         bare-metal system that is the sut. However, if it a virtual
    #         machine that is being tested, it is the virtual-client that
    #         is the sut.
    #
    default_vm_client_template   = 'vm-client-provisioning-job.mako'
    default_testing_job_template = 'testing-job.mako'

    parser = ArgumentParser()

    parser.add_argument('--sut',          required=True,  choices=['real', 'virtual'], help='Kind of SUT to be created.')
    parser.add_argument('--test',         required=False, default='kernel default', help='List of tests that are to be run. This can be one or more tests or test-groups separated by a space.')
    parser.add_argument('--test-options', required=False, default='', help='A string that is passed as is to the kernel-testing script. It can be used to pass environment variables when autotest client is invoked.')

    parser.add_argument('--sut-name',     required=False, default='bogus', help='Hostname of the SUT. This is the name jenkins will attempt to use to connect to the SUT.')
    parser.add_argument('--sut-series',   required=True,  help='The series that is to be installed on the SUT. lts-hwe-<series> denotes that a lts-hwe kernel is to be run on the appropriate lts series.')
    parser.add_argument('--sut-arch',     required=True,  choices=['amd64', 'i386'], help='The architecture (amd64 or i386) that is to be installed on the SUT.')
    parser.add_argument('--sut-hwe',      required=False, action='store_true', default=False, help='The series is for a hwe or backport kernel series.')

    parser.add_argument('--vh-name',      required=False, help='If the SUT is a virtual client, a virtual host is needed. This is the name of that virtual host.')
    parser.add_argument('--vh-series',    required=False, help='If the SUT is a virtual client, a virtual host is needed. This is the series of that virtual host.')
    parser.add_argument('--vh-arch',      required=False, help='If the SUT is a virtual client, a virtual host is needed. This is the arch of that virtual host.')
    parser.add_argument('--vh-hwe',       required=False, action='store_true', default=False, help='The series is for a hwe or backport kernel series.')

    parser.add_argument('--hw',           required=True,  choices=hw['hw pool'].keys(), help='The hardware-name for the system in the hardware database that will be used for the bare metal installation portion of any of these jobs.')

    parser.add_argument('--jenkins-url',  required=False, default='http://kernel-jenkins:8080', help='URL to the jenkins host.')
    parser.add_argument('--no-autostart', required=False, action='store_true', default=False, help='Create the jenkins jobs but do not start them.')
    parser.add_argument('--no-test',      required=False, action='store_true', default=False, help='Don\'t create the test job. Sometimes you just want the job(s) that do the provisioning.')
    parser.add_argument('--tt',           required=False, default=default_testing_job_template, help='The name of the test-job template. (If you don\'t know what this is you shouldn\'t be specifying it.)')
    parser.add_argument('--vm-client-template', required=False, default=default_vm_client_template, help='The name of the template to use for provisioning the virtual-client(s) on the virtual-host. (If you don\'t know what this is you shouldn\'t be specifying it.)')
    parser.add_argument('--has-metrics',        required=False, action='store_true', default=False, help='Use this when the job generates result metrics, in order to collect those.')
    parser.add_argument('--no-provisioning',    required=False, action='store_true', default=False, help='Don\'t create the jobs which do provisioning.')


    args = parser.parse_args()

    # If the sut-name was not specified on the command line, use the
    # HW name.
    #
    if args.sut_name == 'bogus':
        args.sut_name = args.hw

    # If the --test argument is ceph, we use a different set of default
    # templates. That is handled here.
    #
    if args.test == 'ceph':
        if args.vm_client_template == default_vm_client_template:
            args.vm_client_template = 'ceph-cluster-provisioning-job.mako'

    # Using the --hw key specified on the command line, expand the args.hw
    # attribute to contain specifics about that hw system.
    #
    args.hw = hw['hw pool'][args.hw]
    app = SutJobsFactory(args)
    result = app.main()

    info('That\'s All Folks!')
    exit(result)

# vi:set ts=4 sw=4 expandtab:

